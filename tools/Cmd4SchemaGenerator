#!/usr/bin/env node

// Cmd4 Constants and Settings
const constants = require( "../cmd4Constants" );
const settings = require( "../cmd4Settings" );


const which = require('which');
const path = require( "path" );

// Get the real path of homebridge instead of a dev dependancy,
// which caused issues if you forget to update dependancies but
// upgrade homebridge.
const homebridgePath = which.sync( 'homebridge', { nothrow: true } )

const schemaVersionSupport = 6;

let apiPath;
let HomebridgeAPI;
if ( homebridgePath )
{
   let dirname = path.dirname( homebridgePath );

   console.log( "Found homebridge in path %s", dirname );
   apiPath = `${ dirname }/../lib/node_modules/homebridge/lib/api`;
   HomebridgeAPI = require( apiPath ).HomebridgeAPI;

   if ( ! HomebridgeAPI )
   {
      console.log( "homebridgeAPI not available !!!" );
      process.exit( 10 );
   }

} else
{
   console.log( "homebridge not found !!!" );
   process.exit( 10 );
}
console.log( "Found api in %s", apiPath );

let _api = new HomebridgeAPI( ); // object we feed to Plugins
let hapFormats = _api.hap.Formats;

// These would be the uninitialized values.
let CMD4_ACC_TYPE_ENUM = require( '../lib/CMD4_ACC_TYPE_ENUM' );
let CMD4_DEVICE_TYPE_ENUM = require( '../lib/CMD4_DEVICE_TYPE_ENUM' );

// Init the library for all to use
CMD4_ACC_TYPE_ENUM.init( _api.hap );
CMD4_DEVICE_TYPE_ENUM.init( _api.hap, _api.hap.Service );



// Fan, Faucet, Switch, TELEVISION
//let devices = [ 18, 21, 51, 54 ];
// Fan
// let devices = [ 18 ];

// File System utilities
let fs = require( "fs" );

var fid;

var bracketLevel=0;
const INDENT = 3;
var commaRequired = false;
var validatorStates = { REQUIRED: 0, COMMA_HANGING: 1, COLON_HANGINg: 2 };

var validator = validatorStates.NOT_REQUIED;

// For now, put in /tmp
//let CMD4_SCHEMA_FILE = "../config.schema.json";
let CMD4_SCHEMA_FILE = "/usr/local/lib/node_modules/homebridge-cmd4/config.schema.json";


function createSchemaFile( )
{
   // Open the Schema file for writing
   fid = fs.createWriteStream( CMD4_SCHEMA_FILE,
   { flags: "w" // Open for write
   });
   console.log( `Creating Schema file: ${ CMD4_SCHEMA_FILE }` );

   fid.on("error", ( err ) =>
   {
      console.log( "dserror: %s", err );
      process.exit( err );
   });

   commaRequired = false;
   addSchemaHeader( );

   startSchema( );

   addDefinitionsBlock( );

   addAccessorySchemaBlock( );

   endBracketSchema( );

   addLayout( );

   closeSchemaDocument( );

}
//
// Write the beginning blurb
//
function  addSchemaHeader( )
{
   // add the comma always next time.
   if ( commaRequired == true )
      w( `,\n` );

   // Begin bracket JSON
   wf( "+", `{\n` );

   // pluginAlias: The plugin identifier.
   wfs( `"pluginAlias": "${ settings.PLATFORM_NAME }",\n` );

   // pluginType: The type of plugin, valid values are platform or accessory.
   wfs( `"pluginType": "platform",\n` );

   // headerDisplay: Additional content in the user interface above the config form.
   wfs( `"headerDisplay": "Cmd4 Add Accessories",\n` );

   // footerDisplay: Additional content in the user interface below the config form.
   // wfs( `"footerDisplay": "A Sample Footer for Cmd4",\n` );

   // singular: If set to true the UI will not allow the user to add
   // more than one config block. This is usually used for platform
   // plugins where only a single config block should be present.
   wfs( `"singular": false,` );
   wfs( `"customUi": true` );

   commaRequired = true;
}

function startSchema( )
{
   // add the comma always next time.
   if ( commaRequired == true )
      w( `,\n` );

   // * Begin bracket Schema
   wfs( `"schema":\n` );
   wf( "+", `{\n` );
   //wfs ( `"schema": "https://json-schema.org/draft/2020-12/schema",\n`);

   commaRequired = false;
}

function addAccessoryTypeDefinitionBlock( )
{
   // add the comma always next time.
   if ( commaRequired == true )
      w( `,\n` );

   wfs( `"$comment": "START OF TYPE DEFINITION",\n` );
   // *** Begin bracket Type designation definition
   wfs( `"type":\n` );
   wf( "+", `{\n` );
      wfs( `"$id": "#type",\n` );
      wfs( `"type": "string",\n` );
      wfs( `"title": "${ constants.TYPE }",\n` );
      wfs( `"description": "Select the Accessory Type.",\n` );
      wfs( `"default": "Switch",\n` );
      // **** Begin square bracket oneOf for "type"
      wfs( `"oneOf":\n` );
      wf( "+", `[\n` );
         //wfs( `{ "title": "Switch", "enum": ["Switch"] },\n` );

         // Over the Cmd4 Devices
         let deviceCommaRequired = false;
         for ( let index=0; index < CMD4_DEVICE_TYPE_ENUM.EOL; index ++)
         //for ( let j=0; j < devices.length; j++ )
         {
             if ( deviceCommaRequired == true )
                 w(",\n");

             //let index = devices[ j ];
             let deviceName = CMD4_DEVICE_TYPE_ENUM.properties[ index ].deviceName;
             wfs( `{ "title": "${ deviceName }", "enum": ["${ deviceName }"] }` );

             deviceCommaRequired = true ;
         }
         w( "\n" );
      wf( "-", `],\n`, "end square bracket oneOf" );
      wfs( `"required": true\n` );
   wf( "-", `}`, "end bracket Type designation" );

   commaRequired = true;
}

function addPollingDefinitionBlock( )
{
   // add the comma always next time.
   if ( commaRequired == true )
      w( `,\n` );

   wfs( `"$comment": "START OF POLLING DEFINITION",\n` );
   // *** Begin bracket Polling designation definition
   wfs( `"polling":\n` );
   wf( "+", `{\n` );
      wfs( `"$id": "#polling",\n` );
      wfs( `"title": "${ constants.POLLING }",\n` );
      wfs( `"type": "array",\n` );
      wfs( `"required": false,\n` );
      wfs( `"items":\n`);
      wf( "+", `{\n`);
         wfs( `"type": "object",\n` );
         wfs( `"properties":\n` );
         wf( "+", `{\n` );
            wfs( `"characteristic":\n` );
            wf( "+", `{\n` );
               wfs( `"title": "characteristic",\n` );
               wfs( `"type": "string",\n` );
               wfs( `"required": "true"\n` );
            wf( "-", `},` );
            wfs( `"interval":\n` );
            wf( "+", `{\n` );
               wfs( `"title": "interval",\n` );
               wfs( `"type": "number",\n` );
               wfs( `"required": "false"\n` );
            wf( "-", `},` );
            wfs( `"stateChaneResponseTime":\n` );
            wf( "+", `{\n` );
               wfs( `"title": "stateChaneResponseTime",\n` );
               wfs( `"type": "number",\n` );
               wfs( `"required": "false"\n` );
            wf( "-", `},` );
            wfs( `"queue":\n` );
            wf( "+", `{\n` );
               wfs( `"title": "queue",\n` );
               wfs( `"type": "string",\n` );
               wfs( `"required": "false"\n` );
            wf( "-", `}` );
         wf( "-", `}` );
      wf( "-", `}` );
   // *** End bracket Polling designation definition
   wf( "-", `}` );

   commaRequired = true;
}

function addGlobalsDefinitionBlock( )
{
   // add the comma always next time.
   if ( commaRequired == true )
      w( `,\n` );

      wfs( `"debug":\n` );
      wf( "+", `{\n` );
         wfs( `"title": "debug",\n` );
         wfs( `"type": "boolean",\n` );
         wfs( `"description": "Enables additional output in the log.",\n` );
         wfs( `"required": false,\n` );
         wfs( `"placeholder": false\n` );
      wf( "-", `},\n` );
      wfs( `"statusMsg":\n` );
      wf( "+", `{\n` );
         wfs( `"title": "statusMsg",\n` );
         wfs( `"type": "boolean",\n` );
         wfs( `"description": "Enables additional output in the log.",\n` );
         wfs( `"required": false,\n` );
         wfs( `"placeholder": true\n` );
      wf( "-", `},\n` );
      wfs( `"allowTLV8":\n` );
      wf( "+", `{\n` );
         wfs( `"title": "allowTLV8",\n` );
         wfs( `"type": "boolean",\n` );
         wfs( `"description": "Enables wacky TLV8 characteristics.",\n` );
         wfs( `"required": false,\n` );
         wfs( `"placeholder": false\n` );
      wf( "-", `},\n` );
      wfs( `"outputConstants":\n` );
      wf( "+", `{\n` );
         wfs( `"title": "outputConstants",\n` );
         wfs( `"type": "boolean",\n` );
         wfs( `"description": "Output constants instead of values.",\n` );
         wfs( `"required": false,\n` );
         wfs( `"placeholder": false\n` );
      wf( "-", `},\n` );
      wfs( `"timeout":\n` );
      wf( "+", `{\n` );
         wfs( `"title": "timeout",\n` );
         wfs( `"type": "integer",\n` );
         wfs( `"description": "The global timeout for all polling accessories (sec).",\n` );
         wfs( `"required": false,\n` );
         wfs( `"minimum": 3,\n` );
         wfs( `"placeholder": 3\n` );
      wf( "-", `},\n` );
      wfs( `"stateChangeResponseTime":\n` );
      wf( "+", `{\n` );
         wfs( `"title": "stateChangeResponseTime",\n` );
         wfs( `"type": "integer",\n` );
         wfs( `"description": "The time for the accessories to respond (msec).",\n` );
         wfs( `"required": false,\n` );
         wfs( `"placeholder": 60000\n` );
      wf( "-", `},\n` );
      wfs( `"interval":\n` );
      wf( "+", `{\n` );
         wfs( `"title": "interval",\n` );
         wfs( `"type": "integer",\n` );
         wfs( `"description": "Polling interval of all accesssories (sec}.",\n` );
         wfs( `"required": false,\n` );
         wfs( `"minimum": 3,\n` );
         wfs( `"placeholder": 60\n` );
      wf( "-", `},\n` );
      wfs( `"state_cmd_prefix":\n` );
      wf( "+", `{\n` );
         wfs( `"title": "state_cmd_prefix",\n` );
         wfs( `"type": "string",\n` );
         wfs( `"description": "The global state_cmd prefix for all accessories.",\n` );
         wfs( `"required": false\n` );
      wf( "-", `},\n` );
      wfs( `"state_cmd":\n` );
      wf( "+", `{\n` );
         wfs( `"title": "state_cmd",\n` );
         wfs( `"type": "string",\n` );
         wfs( `"description": "The global state_cmd for all accessories.",\n` );
         wfs( `"placeholder": ".homebridge/cmd4Scripts/",\n` );
         wfs( `"required": false\n` );
      wf( "-", `},\n` );
      wfs( `"state_cmd_suffix":\n` );
      wf( "+", `{\n` );
         wfs( `"title": "state_cmd_suffix",\n` );
         wfs( `"type": "string",\n` );
         wfs( `"description": "The global state_cmd suffix for all accessories.",\n` );
         wfs( `"required": false\n` );
      wf( "-", `},\n` );
      wfs( `"storage":\n` );
      wf( "+", `{\n` );
         wfs( `"title": "storage",\n` );
         wfs( `"description": "The FakeGato Storage type for all accessories.",\n` );
         wfs( `"required": false,\n` );
         wfs( `"type": "string",\n` );
         wfs( `"oneOf":\n`);
         wf( "+", `[\n` );
           wfs( `{"title": "fs","enum": ["fs"] },\n` );
           wfs( `{ "title": "googleDrive", "enum": ["googleDrive" ]}\n` );
         wf( "-", `]\n` );
      wf( "-", `},\n` );
      wfs( `"storagePath":\n` );
      wf( "+", `{\n` );
         wfs( `"title": "storagePath",\n` );
         wfs( `"type": "string",\n` );
         wfs( `"description": "The global FakeGato storagePath for all accessories.",\n` );
         wfs( `"required": false\n` );
      wf( "-", `},\n` );
      wfs( `"folder":\n` );
      wf( "+", `{\n` );
         wfs( `"title": "folder",\n` );
         wfs( `"type": "string",\n` );
         wfs( `"description": "The global FakeGato folder for all accessories.",\n` );
         wfs( `"required": false\n` );
      wf( "-", `},\n` );
      wfs( `"keyPath":\n` );
      wf( "+", `{\n` );
         wfs( `"title": "keyPath",\n` );
         wfs( `"type": "string",\n` );
         wfs( `"description": "The FakeGato keyPath for all accessories.",\n` );
         wfs( `"required": false\n` );
      wf( "-", `},\n` );
      wfs( `"definitions":\n` );
      wf( "+", `{\n` );
         wfs( `"title": "definitions",\n` );
         wfs( `"type": "object",\n` );
         wfs( `"description": "complex data.",\n` );
         wfs( `"required": false\n` );
      wf( "-", `},\n` );
      wfs( `"queueTypes":\n` );
      wf( "+", `{\n` );
         wfs( `"title": "queueTypes",\n` );
         wfs( `"type": "array",\n` );
         wfs( `"uniqueItems": true,\n` );
         wfs( `"required": false,\n` );
         wfs( `"items":\n` );
         wf( "+", `{\n` );
            wfs( `"type": "object",\n` );
            wfs( `"properties":\n` );
            wf( "+", `{\n` );
               wfs( `"queue":\n` );
               wf( "+", `{\n` );
                  wfs( `"type": "string",\n` );
                  wfs( `"required": true\n` );
               wf( "-", `},\n` );
               wfs( `"queueType":\n` );
               wf( "+", `{\n` );
                  wfs( `"type": "string",\n` );
                  wfs( `"oneOf":\n` );
                  wf( "+", `[\n` );
                     wfs( `{"title": "WoRm","enum": ["WoRm"] },\n` );
                     wfs( `{ "title": "Sequential", "enum": ["Sequential" ]}\n` );
                 wf( "-", `]\n` );
             wf( "-", `}\n` );
         wf( "-", `}\n` );
      wf( "-", `}\n` );
   wf( "-", `}` );


   commaRequired = true;
}


function addCharacteristicDefinitionBlock( )
{
   // add the comma always next time.
   if ( commaRequired == true )
      w( `,\n` );

   wfs( `"$comment": "START OF CHARACTERISTIC DEFINITIONS",\n` );
   // Over the Cmd4 Characteristics, create pre-definitions
   let characteristicCommaRequired = false;

   for ( let i=0; i < CMD4_ACC_TYPE_ENUM.EOL; i ++)
   {
      let conditionStarted = false;
      let properties = CMD4_ACC_TYPE_ENUM.properties[ i ];
      let characteristicString = properties.sche;
      let description = properties.description;
      let accProps = properties.props;

      // add the comma always next time.
      if ( characteristicCommaRequired == true )
         w( `,\n` );

      // *** Begin bracket characteristic definition
      wfs( `"${ characteristicString }":\n` );
      wf( "+", `{\n` );
         wfs( `"$id": "#${ characteristicString }",\n` );
         wfs( `"title": "${ characteristicString }",\n` );
         switch ( accProps.format )
         {
            case hapFormats.BOOL:
               wfs( `"type": "boolean",\n` );
               break;
            case hapFormats.INT:
            case hapFormats.UINT8:
            case hapFormats.UINT16:
            case hapFormats.UINT32:
            case hapFormats.UINT64:
               wfs( `"type": "integer",\n` );
               break;
            case hapFormats.FLOAT:
               wfs( `"type": "number",\n` );
               break;
            case hapFormats.STRING:
               wfs( `"type": "string",\n` );
               break;
            case hapFormats.DATA:
            case hapFormats.TLV8:
            case hapFormats.DICT:
               wfs( `"type": "string",\n` );
               break;
         }
         if ( accProps.minValue != undefined )
            wfs( `"minimum": ${ accProps.minValue },\n` );
         if ( accProps.maxValue != undefined )
            wfs( `"maximum": ${ accProps.maxValue },\n` );

         wfs( `"description": "${ description }"` );

         for ( let j = 0; j < CMD4_DEVICE_TYPE_ENUM.EOL; j ++ )
         {
            let devProps = CMD4_DEVICE_TYPE_ENUM.properties[ j ];

            devProps.requiredCharacteristics.forEach( ( reqProps ) =>
            {
               if ( reqProps.type == i )
               {
                 if ( conditionStarted == false )
                 {

                    // dtart bracket condition
                    w( `,\n` );
                    wfs( `"condition":\n` );
                    wf( "+", `{\n` );
                        wfs( `"functionBody": "return ['${ devProps.deviceName }'`);
                    conditionStarted = true;
                 } else
                 {
                         w( `,'${ devProps.deviceName }'`);
                 }
              }
           });
         }
         if ( conditionStarted == true )
         {
            if ( accProps.format == hapFormats.TLV8 )
            {
               w( `].includes(model.type) && model.allowTLV8 == true;"\n`);
            } else
            {
               w( `].includes(model.type);"\n`);
            }
            // ***End bracket condition
            wf( "-", `}\n` );
         } else
         {
             w( `\n`);
         }

         // *** End bracket characteristic definition
      wf( "-", `}` );

      characteristicCommaRequired = true;
   }

   commaRequired = true;
}


function addDefinitionsBlock( )
{
   // add the comma always next time.
   if ( commaRequired == true )
      w( `,\n` );

   // ** Begin bracket definitions
   wfs( `"$definitions":\n` );
   wf( "+", `{\n` );

      commaRequired = false;
      addGlobalsDefinitionBlock( );
      addCharacteristicDefinitionBlock( );
      addAccessoryTypeDefinitionBlock( );
      addPollingDefinitionBlock( );

   // ** End bracket definitions
   w( `\n` );
   wf( "-", `}` );

   commaRequired = true;
}


function addAccessorySchemaBlock( )
{
   // add the comma always next time.
   if ( commaRequired == true )
      w( `,\n` );

   // ** Begin bracket properties
   wfs( `"properties":\n` );
   wf( "+", `{\n` );
      wfs( `"${ constants.TYPE }": { "$ref": "#/$definitions/type"},\n` );

      // All the globals that can be defined at the Accessory level
      wfs( `"debug": { "$ref": "#/$definitions/debug"},\n` );
      wfs( `"allowTLV8": { "$ref": "#/$definitions/allowTLV8"},\n` );
      wfs( `"outputConstants": { "$ref": "#/$definitions/outputConstants"},\n` );
      wfs( `"statusMsg": { "$ref": "#/$definitions/statusMsg"},\n` );
      wfs( `"interval": { "$ref": "#/$definitions/interval"},\n` );
      wfs( `"timeout": { "$ref": "#/$definitions/timeout"},\n` );
      wfs( `"stateChangeResponseTime": { "$ref": "#/$definitions/stateChangeResponseTime"},\n` );
      wfs( `"queueTypes": { "$ref": "#/$definitions/queueTypes"},\n` );

      wfs( `"folder": { "$ref": "#/$definitions/folder"},\n` );
      wfs( `"storage": { "$ref": "#/$definitions/storage"},\n` );
      wfs( `"storagePath": { "$ref": "#/$definitions/storagePath"},\n` );
      wfs( `"keyPath": { "$ref": "#/$definitions/keyPath"},\n` );

      // All the characteristics
      for ( let i=0; i < CMD4_ACC_TYPE_ENUM.EOL; i ++)
      {
         let properties = CMD4_ACC_TYPE_ENUM.properties[ i ];
         let characteristicString = properties.sche;

         wfs( `"${ characteristicString }": { "$ref": "#/$definitions/${ characteristicString }"},\n` );
      }

      wfs( `"${ constants.POLLING }": { "$ref": "#/$definitions/polling"},\n` );
      wfs( `"${ constants.STATE_CMD_PREFIX }": { "$ref": "#/$definitions/state_cmd_prefix"},\n` );
      wfs( `"${ constants.STATE_CMD }": { "$ref": "#/$definitions/state_cmd"},\n` );
      wfs( `"${ constants.STATE_CMD_SUFFIX }": { "$ref": "#/$definitions/state_cmd_suffix"}\n` );
   // *** End bracket properties:
   wf( "-", `}\n` );

   commaRequired = true;
}


// $$$$$$$$  LAYOUT  $$$$$$$$$$

function addTypeLayout( )
{
   // add the comma always next time.
   if ( commaRequired == true )
      w( `,\n` );

      wf( "+", `{\n` );
        wfs( `"key": "${ constants.TYPE }",\n` );
        wfs( `"$ref": "#/$definitions/type"\n` );
      wf( "-", `}` );

   commaRequired = true;
}

function addNameLayout( )
{
   // add the comma always next time.
   if ( commaRequired == true )
      w( `,\n` );

   wf( "+", `{\n` );
     wfs( `"key": "name",\n` );
     wfs( `"condition":\n` );
     wf( "+", `{\n` );
        wfs( `"functionBody": "return model.type && model.type !== 'null';"\n` );
     wf( "-", `}\n` );
   wf( "-", `}` );

   commaRequired = true;

}

function addGlobalsLayout( )
{
   // add the comma always next time.
   if ( commaRequired == true )
      w( `,\n` );

   wf( "+", `{\n` );
      wfs( `"title": "Accessory Options",\n` );
      wfs( `"type": "fieldset",\n` );
      wfs( `"expandable": true,\n` );
      wf( "+", `"items": [\n` );
//    wfs( `"items":\n` );
//    wf( "+", `[\n` );
         wfs( `"debug",\n` );
         wfs( `"statusMsg",\n` );
         wfs( `"allowTLV8",\n` );
         wfs( `"outputConstants",\n` );
         wfs( `"timeout",\n` );
         wfs( `"stateChangeResponseTime",\n` );
         wfs( `"interval"\n` );
      wf( "-", `]\n` );
   wf( "-", `}` );

   commaRequired = true;
}


function addStateCmdLayout( )
{
   // add the comma always next time.
   if ( commaRequired == true )
      w( `,\n` );

   wf( "+", `{\n` );
      wfs( `"title": "state_cmd Options",\n` );
      wfs( `"type": "fieldset",\n` );
      wfs( `"expandable": true,\n` );
      wfs( `"items":\n` );
      wf( "+", `[\n` );
         wfs( `"state_cmd_prefix",\n` );
         wfs( `"state_cmd",\n` );
         wfs( `"state_cmd_suffix"\n` );
      wf( "-", `]\n` );
   wf( "-", `}` );

   commaRequired = true;
}


function addFakeGatoLayout( )
{
   // add the comma always next time.
   if ( commaRequired == true )
      w( `,\n` );

   wf( "+", `{\n` );
      wfs( `"title": "FakeGato Options",\n` );
      wfs( `"type": "fieldset",\n` );
      wfs( `"expandable": true,\n` );
      wfs( `"items":\n` );
      wf( "+", `[\n` );
         wf( "+", `{\n` );
            wfs( `"key": "storage", "flex": "1 1 50px",\n` );
            wfs( `"notitle": false, "placeholder": "fs"\n` );
         wf( "-", `},\n` );
         wf( "+", `{\n` );
            wfs( `"key": "storagePath", "flex": "1 1 50px",\n` );
            wfs( `"notitle": false\n` );
         wf( "-", `},\n` );
         wf( "+", `{\n` );
            wfs( `"key": "folder", "flex": "1 1 50px",\n` );
            wfs( `"notitle": false\n` );
         wf( "-", `},\n` );
         wf( "+", `{\n` );
            wfs( `"key": "keyPath", "flex": "1 1 50px",\n` );
            wfs( `"notitle": false\n` );
         wf( "-", `}\n` );
      wf( "-", `]\n` );
   wf( "-", `}` );

   commaRequired = true;
}

function addRequiredCharacteristicPerDeviceLayout( )
{

   wfs( `"$comment": "START OF REQUIRED CHARACTERISTIC LAYOUT PER DEVICE BLOCK",\n` );


   // Over the Cmd4 Devices, create pre-definitions
   for ( let index=0; index < CMD4_DEVICE_TYPE_ENUM.EOL; index ++ )
   {
      let properties = CMD4_DEVICE_TYPE_ENUM.properties[ index ];
      let deviceName = properties.deviceName;
      let requiredCharacteristics = properties.requiredCharacteristics;
      let requireStarted  = false;

      requiredCharacteristics.forEach( ( entry ) =>
      {
         // add the comma always next time.
         if ( commaRequired == true )
         {
             w( `,\n` );
            commaRequired = false;
         }
         let requiredCharacteristic = CMD4_ACC_TYPE_ENUM.accEnumIndexToLC( entry.type );
         // add the comma always next time.
         if ( requireStarted == false )
         {
            requireStarted = true;

            wf( "+", `{\n` );
               wfs( `"type": "fieldset",\n`);
               wfs( `"expandable": true,\n`);
               wfs( `"title": "${ deviceName } Required Characteristics",\n`);
               wfs( `"condition":\n` );
               wf( "+", `{\n` );
                  wfs( `"functionBody": "return ['${ deviceName }'].includes(model.type);"\n` );
               wf( "-", `},\n` );
               wfs( `"items":\n` );
               wf( "+", `[\n` );
                  wfs( `"${ requiredCharacteristic }"` );
          } else
          {
                  w( `,"${ requiredCharacteristic }"` );
          }
      })
      if ( requireStarted == true )
      {
               w( `\n` );
               wf( "-", `]\n` );
             wf( "-", `}` );

             commaRequired = true;
      }

   }

   commaRequired = true;
}

function addOptionalCharacteristicPerDeviceLayout( )
{

   wfs( `"$comment": "START OF REQUIRED CHARACTERISTIC LAYOUT PER DEVICE BLOCK",\n` );


   // Over the Cmd4 Devices, create pre-definitions
   for ( let index=0; index < CMD4_DEVICE_TYPE_ENUM.EOL; index ++ )
   {
      let properties = CMD4_DEVICE_TYPE_ENUM.properties[ index ];
      let deviceName = properties.deviceName;
      let optionalCharacteristics = properties.optionalCharacteristics;
      let optionalStarted  = false;

      optionalCharacteristics.forEach( ( entry ) =>
      {
         // add the comma always next time.
         if ( commaRequired == true )
         {
             w( `,\n` );
            commaRequired = false;
         }
         let optionalCharacteristic = CMD4_ACC_TYPE_ENUM.accEnumIndexToLC( entry );
         // add the comma always next time.
         if ( optionalStarted == false )
         {
            optionalStarted = true;

            wf( "+", `{\n` );
               wfs( `"type": "fieldset",\n`);
               wfs( `"expandable": true,\n`);
               wfs( `"title": "${ deviceName } Optional Characteristics",\n`);
               wfs( `"condition":\n` );
               wf( "+", `{\n` );
                  wfs( `"functionBody": "return ['${ deviceName }'].includes(model.type);"\n` );
               wf( "-", `},\n` );
               wfs( `"items":\n` );
               wf( "+", `[\n` );
                  wfs( `"${ optionalCharacteristic }"` );
          } else
          {
                  w( `,"${ optionalCharacteristic }"` );
          }
      })
      if ( optionalStarted == true )
      {
               w( `\n` );
               wf( "-", `]\n` );
             wf( "-", `}` );

             commaRequired = true;
      }

   }

   commaRequired = true;
}


function addQueueTypesLayout( )
{
   wfs( `"$comment": "START OF QUEUE TYPES LAYOUT BLOCK",\n` );

   // add the comma always next time.
   if ( commaRequired == true )
   {
      w( `,\n` );
      commaRequired = false;
   }

   wf( "+", `{\n` )
     wfs( `"key": "queueTypes",\n` );
     wfs( `"type": "array",\n` );
     wfs( `"listItems": 1,\n` );
     wfs( `"items":\n` );
     wf( "+", `[\n` );
        wf( "+", `{\n` );
           wfs( `"type": "div",\n` );
           wfs( `"displayFlex": true,\n` );
           wfs( `"flex-direction": "row",\n` );
           wfs( `"items":\n` );
           wf( "+", `[\n` );
              wf( "+", `{\n` );
                  wfs( `"key": "queueTypes[].queue", "flex": "1 1 50px",\n` );
                  wfs( `"notitle": false, "placeholder": "AQueueName"\n` );
               wf( "-", `},\n` );
               wf( "+", `{\n` );
                 wfs( `"key": "queueTypes[].queueType", "flex": "4 4 200px",\n` );
                 wfs( `"notitle": false, "placeholder": "WoRm"\n` );
               wf( "-", `}\n` );
            wf( "-", `]\n` );
         wf( "-", `}\n` );
      wf( "-", `]\n` );
   wf( "-", `}` );

   commaRequired = true;
}

// $$$$$$$$$$$$$$$$$$$$$$$$$$$$


function endBracketSchema( )
{
   // * End bracket Schema
   wf( "-", `}` );

   commaRequired = true;
}

function addLayout( )
{
   // add the comma always next time.
   if ( commaRequired == true )
      w( `,\n` );

   // * Begin square bracket layout:
   wfs( `"layout":\n` );
   wf( "+", `[\n` );

      commaRequired = false;

      addTypeLayout( );
      addNameLayout( );
      addGlobalsLayout( );
      addFakeGatoLayout( );
      addQueueTypesLayout( );
      addRequiredCharacteristicPerDeviceLayout( );
      addOptionalCharacteristicPerDeviceLayout( );
      addStateCmdLayout( );

   // * End square bracket layout:
   wf( "-", `]\n` );

   commaRequired = true;
}

function closeSchemaDocument( )
{
   // End bracket JSON
   wf( "-", `}\n` );

   // Close the Schema file
   fid.end( );
}


// Write to fid the given text, increasing or decreasing bracketLevel.
function wf( level, text )
{
   // Subtract now
   switch( level)
   {
      case "-":
         bracketLevel--;
         //     text != "}"  && text != "}\n"  &&
         //     text != "}," && text != "},\n" &&
         //     text != "]"  && text != "]\n"  &&
         //     text != "],"  && text != "],\n"

         //  match exactly 1 of either } or : or ]
         // [}\]]{1}[,]?\n*
         //  optionally followed by 0 or 1 commas
         // [}\]]{1}[,]?\n*
         //  followed by 0 or more newline characters
         // [}\]]{1}[,]?\n*
         //  at end of line
         // [}\]]{1}[,]?\n*$
         if ( text.match( /[}\]]{1}[,]?\n*$/ ) )
         {
            // noop
         } else
            throw new Error ( `Invalid text for closed level. text: ${ text }` );
         break;
      case "+":
         //  match exactly 1 of either { or : or {
         //    [\{:\[]{1}
         //  followed by 0 or more spaces
         //    [\{:\[]{1}\s*
         //  followed by 0 or more newline characters
         //    [\{:\[]{1}\s*[\n]*
         //  at end of line
         //    [\{:\[]{1}\s*[\n]*$
         //

         //if ( text != "{"  && text != "{\n"  &&
         //     text != "["  && text != "[\n"  &&
         if ( text.match( /[{:[]{1}\s*[\n]*$/ ) )
         {
            // noop
         } else
            throw new Error ( `Invalid text for open level. text: ${ text }` );
         break;
      case "nc":

         break;
      default:
         throw new Error ( `Invalid level: ${ level }` );
   }

   if ( bracketLevel < 0 )
      throw new Error( `two many closed braces ${ bracketLevel } for text: ${ text }` );

   // We need to check to see if the text first starts with a comma
   // as it changes the validator

   //  From the beginning of the line
   //   ^
   //  match 0 or more spaces
   //   ^\s*,
   //  followed by a comma
   //   ^\s*,
   if ( text.match(/^\s*,/) &&
        ( validator == validatorStates.COMMA_HANGING ||
          validator == validatorStates.COLON_HANGING )
      )
   {
      throw new Error( `Additional hanging comma for text: ${ text }` );
   } else if ( text.match(/^\s+:/) &&
               ( validator == validatorStates.COMMA_HANGING ||
                 validator == validatorStates.COLON_HANGING )
             )
   {
      throw new Error( `Additional hanging colon for text: ${ text }` );
   } else
   {
      validator = validatorStates.REQUIRED;
   }

   // Now we can check if a level change causes a comma
   // to be hung.
   if (  validator == validatorStates.COMMA_HANGING )
      if ( level == "+" )
         throw new Error( `Adding Open bracket leaves comma hanging for text: ${ text }` );
      else if ( level == "-" )
         throw new Error( `Adding Closed bracket leaves comma hanging for text: ${ text }` );


   fid.write( " ".repeat( bracketLevel * INDENT ).concat( text ) );

   if ( text.endsWith( "," ) || text.endsWith( ",\n"  ) ||
        text.endsWith( ", ") || text.endsWith( ", \n" )
      )
   {
      validator = validatorStates.COMMA_HANGING;
   } else if ( text.endsWith( ":" ) || text.endsWith( ":\n"  ) ||
               text.endsWith( ": ") || text.endsWith( ": \n" )
             )
   {
      validator = validatorStates.COLON_HANGING;
   }

   // Add later
   if ( level == "+" )
      bracketLevel++;
}

// Convenience function for wfs. writing to same level.
function wfs( text )
{
   // Ignore comments that are only available in version 7+
   if ( schemaVersionSupport <= 6 && text.startsWith( `"$comment"` ) )
   {
      // nc
   } else
   {
      wf( "nc", text );
   }
}
// Convenience function to write to fid, no formatting, as is.
function w( text )
{
   fid.write( text );

   // We need to check to see if the text first starts with a comma
   // as it changes the validator
   if ( text.match(/\s+,/) &&
        validator == validatorStates.COMMA_HANGING )
   {
      throw new Error( `Additional hanging comma for text: ${ text }` );
   } else
   {
      validator = validatorStates.REQUIRED;
   }

   // Now we can check there was possibly a level change
   // that should have used wfs
   if ( text.startsWith( "{" ) ||
        text.startsWith( "}" )
        // Does not play nicely with layout
        // wfs( `"functionBody": "return ['${ devProps.deviceName }'`);
        //   w( `].includes(model.type);"\n`);
        // text.match(/\s+]/) ||
        // text.match(/\s+[/)
      )
   {
      console.log( `Warning, adding brackets without calling wfs for text: ${ text }` );
   }

   if ( text.endsWith( ",")  || text.endsWith( ",\n"  ) ||
        text.endsWith( ", ") || text.endsWith( ", \n" )
      )
   {
      validator = validatorStates.COMMA_HANGING;
   } else
   {
      validator = validatorStates.REQUIRED;
   }
}

createSchemaFile( );


if ( bracketLevel == 0)
{
   console.log( `Yahoo !  All lined up.` );
} else
{
   console.log( `Booo ... alignment failed: [ ${ Number(bracketLevel > 0) + bracketLevel } ]` );
}
if (  validator == validatorStates.REQUIRED )
{
   console.log( `Yahoo !  No hanging commas.` );
} else
{
   console.log( `Booo ... comma left hanging ${ validator }` );
}
return bracketLevel;
