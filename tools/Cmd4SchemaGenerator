#!/usr/bin/env node


// Cmd4 Constants and Settings
const constants = require( "../cmd4Constants" );
const settings = require( "../cmd4Settings" );
const path = require( "path" );
let fs = require( "fs" );

//const CMD4_SCHEMA_FILE = "./config.schema.json";
let CMD4_BASE_PATH = ".";
//let CMD4_BASE_PATH = "/usr/local/lib/node_modules/homebridge-cmd4;
const CMD4_CONFIG_FILE = "Extras/config.json";

const CMD4_SCHEMA_FILE = "config.schema.json";
const CMD4_ACCESSORY_SCHEMA_FILE = "homebridge-ui/public/js/accessorySchema.js";
const CMD4_ACCESSORY_SCHEMA_FILE2 = "homebridge-ui/public/js/accessorySchema2.js";
const CMD4_GLOBALS_SCHEMA_FILE = "homebridge-ui/public/js/globalsSchema.js";

const schemaVersionSupport = 6;
let _api;
let hapFormats;


// These would be the uninitialized values.
let CMD4_ACC_TYPE_ENUM = require( '../lib/CMD4_ACC_TYPE_ENUM' );
let CMD4_DEVICE_TYPE_ENUM = require( '../lib/CMD4_DEVICE_TYPE_ENUM' );

// Formatting stuff
var fid;
var bracketLevel=0;
const INDENT = 3;
var commaRequired_g = false;
var previousText = "";
var validatorStates = { CLEAR: 0,
                        COMMA_HANGING: 1,
                        COLON_HANGING: 2,
                        OPEN_ROUND_BRACKET_HANGING: 3,
                        CLOSED_ROUND_BRACKET_HANGING: 4,
                        OPEN_SQUARE_BRACKET_HANGING: 5,
                        CLOSED_SQUARE_BRACKET_HANGING: 6,
                        OPEN_SQUIGGLY_BRACKET_HANGING: 7,
                        CLOSED_SQUIGGLY_BRACKET_HANGING: 8,
                        DOUBLE_QUOTE_HANGING: 9,
                        NONE_FOUND: 10
                      };
var validator_g = validatorStates.CLEAR;


// This should be clled if another schema document is to be created.
function reInit()
{
   validator_g = validatorStates.CLEAR;
   bracketLevel=0;
   commaRequired_g = false;
   previousText = "";
}

function getHomebridgeVars( )
{
   const which = require('which');
   let apiPath;
   let HomebridgeAPI;

   // Get the real path of homebridge instead of a dev dependancy,
   // which caused issues if you forget to update dependancies but
   // upgrade homebridge.
   const homebridgePath = which.sync( 'homebridge', { nothrow: true } )

   if ( homebridgePath )
   {
      let dirname = path.dirname( homebridgePath );

      console.log( "Found homebridge in path %s", dirname );
      apiPath = `${ dirname }/../lib/node_modules/homebridge/lib/api`;
      HomebridgeAPI = require( apiPath ).HomebridgeAPI;

      if ( ! HomebridgeAPI )
      {
         console.log( "homebridgeAPI not available !!!" );
         process.exit( 10 );
      }

   } else
   {
      console.log( "homebridge not found !!!" );
      process.exit( 10 );
   }
   console.log( "Found api in %s", apiPath );

   _api = new HomebridgeAPI( ); // object we feed to Plugins
   hapFormats = _api.hap.Formats;
}

// Create the accessorySchema.js file
function createAccessorySchemaFile( )
{
   reInit( );

   let schemaFile = `${ CMD4_BASE_PATH }/${ CMD4_ACCESSORY_SCHEMA_FILE }`;
   console.log( `\nCreating ${ CMD4_ACCESSORY_SCHEMA_FILE }  file: ${ schemaFile }` );
   // Open the Schema file for writing
   fid = fs.openSync( schemaFile, "w" ); // Open for write

// fid.on("error", ( err ) =>
// {
//    console.log( "dserror: %s", err );
//    process.exit( err );
// });

   wf( `/*eslint no-unused-vars: ["error", { "varsIgnorePattern": "accessorySchema" }]*/\n\n` );

   wf( `const accessorySchema =\n` );
   wf( "+", `{\n` );   // For vi % balance: }
      commaRequired_g = false;

      // Not in accessorySchema
      //  beginJSON( );
      // addSchemaHeader( );

      startSchema( );

         // add the comma always next time.
         if ( commaRequired_g == true )
            wf( `,\n` );

         // ** Begin bracket defs
         wf( `"$defs":\n` );
         wf( "+", `{\n` );

            commaRequired_g = false;

            // These are all defs, even if not used by schema
            addDefinitionBlock(); // incomplete (just returns)
            addGlobalsDefinitionBlock( );
            addPublishExternallyDefinitionBlock( );
            addCharacteristicDefinitionBlock( );

            addAccessoryTypeDefinitionBlock( );
            addSubTypeDefinitionBlock( );
            addDisplayNameDefinitionBlock( );
            addQueueDefinitionBlock( );
            addPollingDefinitionBlock( );
            // addAccessoryDefinitionBlock( );
            addFakeGatoDefinitionBlock( );

         // ** End bracket defs
         wf( `\n` );
         wf( "-", `}` );

         commaRequired_g = true;

         // For Accessory Schema
         beginSchemaProperties( );
            wf( `"${ constants.TYPE }": { "$ref": "#/$defs/type"},\n` );
            addGlobalsSchemaBlockForSchema( "Accessory" );
            addCharacteristicsSchemaBlock( );
            addQueueSchemaBlock( );
            addPollingSchemaBlock( );
            addStateCmdSchemaBlock( );
            addFakeGatoSchemaBlock( );
         endSchemaProperties( );

      endBracketSchema( );

   // addLayout( ); // for accessorySchema
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   // * Begin square bracket layout:
   wf( `"layout":\n` );
   wf( "+", `[\n` );

      commaRequired_g = false;

      // For Accessory Schema
      addTypeLayout( );
      addNameLayout( );
      addGlobalsLayoutForSchema( "Accessory" );

      // Not in Accessory Schema
      // addQueueTypesLayoutForSchema( "Accessory" );

      addRequiredCharacteristicPerDeviceLayout( );
      addOptionalCharacteristicPerDeviceLayout( );
      addPollingLayout( );
      addStateCmdLayoutForSchema( );
      addFakeGatoLayout( );
   // * End square bracket layout:
   wf( "-", `]\n` );

   commaRequired_g = true;

   closeSchemaDocument( );
}

// Create the accessorySchema.js file
function createAccessorySchemaFile2( )
{
   reInit( );

   let schemaFile = `${ CMD4_BASE_PATH }/${ CMD4_ACCESSORY_SCHEMA_FILE2 }`;
   console.log( `\nCreating ${ CMD4_ACCESSORY_SCHEMA_FILE2 }  file: ${ schemaFile }` );
   // Open the Schema file for writing
   fid = fs.openSync( schemaFile, "w" ); // Open for write

// fid.on("error", ( err ) =>
// {
//    console.log( "dserror: %s", err );
//    process.exit( err );
// });

   wf( `/*eslint no-unused-vars: ["error", { "varsIgnorePattern": "accessorySchema" }]*/\n\n` );

   wf( `const accessorySchema =\n` );
   wf( "+", `{\n` );   // For vi % balance: }
      commaRequired_g = false;

      // Not in accessorySchema
      //  beginJSON( );
      // addSchemaHeader( );

      startSchema( );

         // add the comma always next time.
         if ( commaRequired_g == true )
            wf( `,\n` );

         // ** Begin bracket defs
         wf( `"$defs":\n` );
         wf( "+", `{\n` );

            commaRequired_g = false;

   // Accessory2
            // These are all defs, even if not used by schema
            addDefinitionBlock(); // incomplete (just returns)
            addGlobalsDefinitionBlock( );
            addPublishExternallyDefinitionBlock( );
            addCharacteristicDefinitionBlock( );

            // addAccessoryTypeDefinitionBlock( );
            addSubTypeDefinitionBlock( );
            addDisplayNameDefinitionBlock( );
            addQueueDefinitionBlock( );
            addPollingDefinitionBlock( );
            // addAccessoryDefinitionBlock( );
            addFakeGatoDefinitionBlock( );

   addIndividualCompleteAccessoryDefinitionBlocks( );

         // ** End bracket defs
         wf( `\n` );
         wf( "-", `}` );

         commaRequired_g = true;

         // For Accessory Schema
         beginSchemaProperties( );
            for ( let index=0; index < CMD4_DEVICE_TYPE_ENUM.EOL; index ++)
            {
               if ( commaRequired_g == true )
                  wf( `,\n` );

               let deviceName = CMD4_DEVICE_TYPE_ENUM.properties[ index ].deviceName;

               wf( `"${ deviceName }": { "$ref": "#/$defs/${ deviceName }"}` );
               commaRequired_g = true;
            }
         endSchemaProperties( );

      endBracketSchema( );

   // addLayout( ); // for accessorySchema
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   // * Begin square bracket layout:
   wf( `"layout":\n` );
   wf( "+", `[\n` );

      commaRequired_g = false;

      // For ** Accessory2 ** Layout
      addConditionalLayoutForDeviceType( );
      //addNameLayout( );

      //addTypeLayout( );
      //addGlobalsLayoutForSchema( "Accessory" );

      // Not in Accessory Schema
      // addQueueTypesLayoutForSchema( "Accessory" );

      //addRequiredCharacteristicPerDeviceLayout( );
      //addOptionalCharacteristicPerDeviceLayout( );
      //addPollingLayout( );
      //addStateCmdLayoutForSchema( );
      //addFakeGatoLayout( );
   // * End square bracket layout:
   wf( "-", `]\n` );

   commaRequired_g = true;

   closeSchemaDocument( );
}

// Create the globalsSchema.js file
function createGlobalsSchemaFile( )
{
   reInit( );

   let schemaFile = `${ CMD4_BASE_PATH }/${ CMD4_GLOBALS_SCHEMA_FILE }`;
   // Open the Schema file for writing
   fid = fs.openSync( schemaFile, "w" ); // Open for write
   console.log( `\nCreating ${ CMD4_GLOBALS_SCHEMA_FILE }  file: ${ schemaFile }` );

// fid.on("error", ( err ) =>
// {
//    console.log( "dserror: %s", err );
//    process.exit( err );
// });

   wf( `/*eslint no-unused-vars: ["error", { "varsIgnorePattern": "globalsSchema" }]*/\n\n` );

   wf( `const globalsSchema =\n`);
   wf( "+", `{\n`);   // For vi % balance: }

      commaRequired_g = false;
      // Not in globalsySchema
      //  beginJSON( );
      //addSchemaHeader( );

      startSchema( );

         // add the comma always next time.
         if ( commaRequired_g == true )
            wf( `,\n` );

         // ** Begin bracket defs
         wf( `"$defs":\n` );
         wf( "+", `{\n` );

            commaRequired_g = false;

            // These are all defs, even if not used by schema
            addGlobalsDefinitionBlock( );
            //addPublishExternallyDefinitionBlock( );
            //addCharacteristicDefinitionBlock( );
            //addAccessoryTypeDefinitionBlock( );
            //addSubTypeDefinitionBlock( );
            //addDisplayNameDefinitionBlock( );
            //addQueueDefinitionBlock( );
            //addPollingDefinitionBlock( );
            //addAccessoryDefinitionBlock( );
            //addFakeGatoDefinitionBlock( );

         // ** End bracket defs
         wf( `\n` );
         wf( "-", `}` );

         commaRequired_g = true;

         // For just Globals Schema
         beginSchemaProperties( );
            addGlobalsSchemaBlockForSchema( "Global" );
            // Not in globalsySchema
            // addCharacteristicsSchemaBlock( );
            // addQueueSchemaBlock( );
            // addPollingSchemaBlock( );
            addStateCmdSchemaBlock( );
            // addFakeGatoSchemaBlock( );
         endSchemaProperties( );

      endBracketSchema( );

   // addLayout( ); // for globalsSchema
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   // * Begin square bracket layout:
   wf( `"layout":\n` );
   wf( "+", `[\n` );

      commaRequired_g = false;

      // addTypeLayout( );
      // addNameLayout( );
      addGlobalsLayoutForSchema( "Global" );

      addQueueTypesLayoutForSchema( "Global" );
      // addRequiredCharacteristicPerDeviceLayout( );
      // addOptionalCharacteristicPerDeviceLayout( );
      addStateCmdLayoutForSchema( "Global" );

      // Not in Global
      // addFakeGatoLayout( );

   // * End square bracket layout:
   wf( "-", `]\n` );

   commaRequired_g = true;

   closeSchemaDocument( );
}

function createSchemaFile( )
{
   let schemaFile = `${ CMD4_BASE_PATH }/${CMD4_SCHEMA_FILE }`;
   // Open the Schema file for writing
   fid = fs.openSync( schemaFile, "w" ); // Open for write
   console.log( `\nCreating Schema file: ${ schemaFile }` );

// fid.on("error", ( err ) =>
// {
//    console.log( "dserror: %s", err );
//    process.exit( err );
// });

   commaRequired_g = false;

   beginJSON( );

      addSchemaHeader( );

      startSchema( );

         // add the comma always next time.
         if ( commaRequired_g == true )
            wf( `,\n` );

         // ** Begin bracket defs
         wf( `"$defs":\n` );
         wf( "+", `{\n` );

            commaRequired_g = false;

            // These are all defs, even if not used by schema
            addGlobalsDefinitionBlock( );
            addPublishExternallyDefinitionBlock( );
            addCharacteristicDefinitionBlock( );
            addAccessoryTypeDefinitionBlock( );
            addSubTypeDefinitionBlock( );
            addDisplayNameDefinitionBlock( );
            addQueueDefinitionBlock( );
            addPollingDefinitionBlock( );
            addAccessoryDefinitionBlock( );
            addFakeGatoDefinitionBlock( );

         // ** End bracket defs
         wf( `\n` );
         wf( "-", `}` );

         commaRequired_g = true;

         // For Full Schema
         beginSchemaProperties( );
            addGlobalsSchemaBlockForSchema( "Full" );
            addCharacteristicsSchemaBlock( );
            addQueueSchemaBlock( );
            addPollingSchemaBlock( );
            addStateCmdSchemaBlock( );
            addFakeGatoSchemaBlock( );
         endSchemaProperties( );

      endBracketSchema( );

   // addLayout( ); // for config.schema.json
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   // * Begin square bracket layout:
   wf( `"layout":\n` );
   wf( "+", `[\n` );

      commaRequired_g = false;

      // For Full Schema
      addTypeLayout( );
      addNameLayout( );
      addGlobalsLayoutForSchema( "Accessory" );
      addQueueTypesLayoutForSchema( );
      addRequiredCharacteristicPerDeviceLayout( );
      addOptionalCharacteristicPerDeviceLayout( );
      addPollingLayout( );
      addStateCmdLayoutForSchema( );
      addFakeGatoLayout( );

   // * End square bracket layout:
   wf( "-", `]\n` );

   commaRequired_g = true;

   closeSchemaDocument( );
}

function beginJSON( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   // Begin bracket JSON
   wf( "+", `{\n` );   // For vi % balance: }

   commaRequired_g = false;
}

//
// Write the beginning blurb
//
function  addSchemaHeader( )
{
   if ( commaRequired_g == true )
      wf( `,\n` );

   // pluginAlias: The plugin identifier.
   wf( `"pluginAlias": "${ settings.PLATFORM_NAME }",\n` );

   // pluginType: The type of plugin, valid values are platform or accessory.
   wf( `"pluginType": "platform",\n` );

   // headerDisplay: Additional content in the user interface above the config form.
   wf( `"headerDisplay": "Cmd4 Add Accessories",\n` );

   // footerDisplay: Additional content in the user interface below the config form.
   // wf( `"footerDisplay": "A Sample Footer for Cmd4",\n` );

   // singular: If set to true the UI will not allow the user to add
   // more than one config block. This is usually used for platform
   // plugins where only a single config block should be present.
   wf( `"singular": false,` );
   wf( `"customUi": true` );

   commaRequired_g = true;
}

function startSchema( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   // * Begin bracket Schema
   wf( `"schema":\n` );
   wf( "+", `{\n` );   // For vi % balance: }
   //w ( `"schema": "https://json-schema.org/draft/2020-12/schema",\n`);

   commaRequired_g = false;
}

function addPublishExternallyDefinitionBlock( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( `"$comment": "START OF PublishExternally DEFINITION",\n` );
   // *** Begin bracket PublishExternally definition Block
   wf( `"publishExternally":\n` );
   wf( "+", `{\n` );
      wf( `"type": "boolean",\n` );
      wf( `"title": "publishExternally",\n` );
      wf( `"description": "Publish accessory externally.",\n` );
      wf( `"default": false,\n` );
      wf( `"required": false\n` );
   wf( "-", `}`, "end bracket PublishExternally definition" );

   commaRequired_g = true;
}

function addSubTypeDefinitionBlock( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( `"$comment": "START OF subType DEFINITION",\n` );
   // *** Begin bracket subType designation definition Block
   wf( `"subType":\n` );
   wf( "+", `{\n` );
      wf( `"type": "string",\n` );
      wf( `"title": "subType",\n` );
      wf( `"description": "The accessories subType.",\n` );
      wf( `"placeholder": "A secondary name",\n` );
      wf( `"required": false\n` );
   wf( "-", `}`, "end bracket subType designation" );

   commaRequired_g = true;
}

function addDisplayNameDefinitionBlock( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( `"$comment": "START OF displayName DEFINITION",\n` );
   // *** Begin bracket displayName definition Block
   wf( `"displayName":\n` );
   wf( "+", `{\n` );
      wf( `"type": "string",\n` );
      wf( `"title": "displayName",\n` );
      wf( `"description": "The accessories display name.",\n` );
      wf( `"placeholder": "My_Device",\n` );
      wf( `"required": true\n` );
   wf( "-", `}`, "end bracket displayName designation" );

   commaRequired_g = true;
}


function addAccessoryTypeDefinitionBlock( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( `"$comment": "START OF type DEFINITION",\n` );
   // *** Begin bracket Type definition Block
   wf( `"type":\n` );
   wf( "+", `{\n` );
      wf( `"type": "string",\n` );
      wf( `"title": "${ constants.TYPE }",\n` );
      wf( `"description": "Select the Accessory Type.",\n` );
      wf( `"default": "Switch",\n` );
      // **** Begin square bracket oneOf for "type"
      wf( `"oneOf":\n` );
      wf( "+", `[\n` );
         //Example: { "title": "Switch", "enum": ["Switch"] },

         // Over the Cmd4 Devices
         let deviceCommaRequired = false;
         for ( let index=0; index < CMD4_DEVICE_TYPE_ENUM.EOL; index ++)
         //for ( let j=0; j < devices.length; j++ )
         {
             if ( deviceCommaRequired == true )
                 wf(",\n");

             //let index = devices[ j ];
             let deviceName = CMD4_DEVICE_TYPE_ENUM.properties[ index ].deviceName;
             wf( `{ "title": "${ deviceName }", "enum": ["${ deviceName }"] }` );

             deviceCommaRequired = true ;
         }
         wf( "\n" );
      wf( "-", `],\n`, "end square bracket oneOf" );
      wf( `"required": true\n` );
   wf( "-", `}`, "end bracket Type designation" );

   commaRequired_g = true;
}

function addQueueDefinitionBlock( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( `"queue":\n` );
   wf( "+", `{\n` );
      wf( `"title": "queue",\n` );
      wf( `"description": "A queue name",\n` );
      wf( `"type": "string",\n` );
      wf( `"required": "false"\n` );
   wf( "-", `}` );

   commaRequired_g = true;
}

function addPollingDefinitionBlock( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( `"$comment": "START OF polling DEFINITION",\n` );
   // *** Begin bracket Polling definition Block
   wf( `"polling":\n` );
   wf( "+", `{\n` );
      wf( `"title": "${ constants.POLLING }",\n` );
      wf( `"type": "array",\n` );
      wf( `"required": false,\n` );
      wf( `"uniqueItems": true,\n` );
      wf( `"$comment": "This will have to Increase as each added are validated",\n` );
      wf( `"maxItems": 0,\n` );
      wf( `"items":\n`);
      wf( "+", `{\n`);
         wf( `"type": "object",\n` );
         wf( `"properties":\n` );
         wf( "+", `{\n` );
            wf( `"characteristic":\n` );
            wf( "+", `{\n` );
               wf( `"title": "characteristic",\n` );
               wf( `"type": "string",\n` );
               wf( `"required": "true"\n` );
            wf( "-", `},\n` );
            wf( `"timeout": {"$ref": "#/$defs/timeout"},\n` );
            wf( `"interval": { "$ref": "#/$defs/interval"},\n` );
            wf( `"stateChangeResponseTime": {"$ref": "#/$defs/stateChangeResponseTime"}\n` );
         wf( "-", `}\n` );
      wf( "-", `}\n` );
   // *** End bracket Polling definition Block
   wf( "-", `}` );

   commaRequired_g = true;
}

function addFakeGatoDefinitionBlock( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( `"$comment": "START OF fakegato DEFINITION",\n` );
   // *** Begin bracket FakeGato definition Block

   wf( "+", `"fakegato": {\n` );
      wf( `"title": "fakegato",\n` );
      wf( `"type": "object",\n` );
      wf( `"required": "false",\n` );
      wf( "+", `"properties": {\n` );
         wf( "+", `"eve": {\n` );
            wf( `"type": "string",\n` );
            wf( `"title": "eve",\n` );
            wf( `"description": "FakeGato Accessory Type.",\n` );
            wf( `"default": "room",\n` );
            wf( "+", `"oneOf": [\n` );
               wf( `{ "title": "${ constants.FAKEGATO_TYPE_ENERGY }", "enum": ["${ constants.FAKEGATO_TYPE_ENERGY }"] },\n` );
               wf( `{ "title": "${ constants.FAKEGATO_TYPE_ROOM }", "enum": ["${ constants.FAKEGATO_TYPE_ROOM }"] },\n` );
               wf( `{ "title": "${ constants.FAKEGATO_TYPE_WEATHER }", "enum": ["${ constants.FAKEGATO_TYPE_WEATHER }"] },\n` );
               wf( `{ "title": "${ constants.FAKEGATO_TYPE_DOOR }", "enum": ["${ constants.FAKEGATO_TYPE_DOOR }"] },\n` );
               wf( `{ "title": "${ constants.FAKEGATO_TYPE_MOTION }", "enum": ["${ constants.FAKEGATO_TYPE_MOTION }"] },\n` );
               wf( `{ "title": "${ constants.FAKEGATO_TYPE_THERMO }", "enum": ["${ constants.FAKEGATO_TYPE_THERMO }"] },\n` );
               wf( `{ "title": "${ constants.FAKEGATO_TYPE_AQUA }", "enum": ["${ constants.FAKEGATO_TYPE_AQUA }"] }\n` );
            wf( "-", `],\n`, "End square bracket oneOf" );
            wf( `"required": true\n` );
         wf( "-", `},\n`, "End bracket eve designation" );

         wf( "+", `"power": {\n` );
            wf( `"type": "string",\n` );
            wf( `"title": "power",\n` );
            wf( `"description": "FakeGato Accessory Type.",\n` );
            wf( `"default": "room",\n` );
            wf( "+", `"oneOf": [\n` );
               wf( `{ "title": "${ constants.STATUS }", "enum": ["${ constants.STATUS }"] },\n` );
               wf( `{ "title": "${ constants.TEMP }", "enum": ["${ constants.TEMP }"] },\n` );
               wf( `{ "title": "${ constants.SETTEMP }", "enum": ["${ constants.SETTEMP }"] },\n` );
               wf( `{ "title": "${ constants.HUMIDITY }", "enum": ["${ constants.HUMIDITY }"] },\n` );
               wf( `{ "title": "${ constants.PPM }", "enum": ["${ constants.PPM }"] },\n` );
               wf( `{ "title": "${ constants.POWER }", "enum": ["${ constants.POWER }"] },\n` );
               wf( `{ "title": "${ constants.PRESSURE }", "enum": ["${ constants.PRESSURE }"] },\n` );
               wf( `{ "title": "${ constants.CURRENTTEMP }", "enum": ["${ constants.CURRENTTEMP }"] },\n` );
               wf( `{ "title": "${ constants.VALVEPOSITION }", "enum": ["${ constants.VALVEPOSITION }"] }\n` );
            wf( "-", `],\n`, "end square bracket oneOf" );
            wf( `"required": true\n` );
         wf( "-", `},\n`, "End bracket power designation" );

         wf( `"storage":\n` );
         wf( "+", `{\n` );
            wf( `"title": "storage",\n` );
            wf( `"description": "The FakeGato Storage type for all accessories.",\n` );
            wf( `"required": false,\n` );
            wf( `"type": "string",\n` );
            wf( `"oneOf":\n`);
            wf( "+", `[\n` );
              wf( `{ "title": "fs", "enum": ["fs"] },\n` );
              wf( `{ "title": "googleDrive", "enum": [ "googleDrive" ]}\n` );
            wf( "-", `]\n` );
         wf( "-", `},\n` );
         wf( `"storagePath":\n` );
         wf( "+", `{\n` );
            wf( `"title": "storagePath",\n` );
            wf( `"type": "string",\n` );
            wf( `"description": "The global FakeGato storagePath for all accessories.",\n` );
            wf( `"required": false\n` );
         wf( "-", `},\n` );
         wf( `"folder":\n` );
         wf( "+", `{\n` );
            wf( `"title": "folder",\n` );
            wf( `"type": "string",\n` );
            wf( `"description": "The global FakeGato folder for all accessories.",\n` );
            wf( `"required": false\n` );
         wf( "-", `},\n` );
         wf( `"keyPath":\n` );
         wf( "+", `{\n` );
            wf( `"title": "keyPath",\n` );
            wf( `"type": "string",\n` );
            wf( `"description": "The FakeGato keyPath for all accessories.",\n` );
            wf( `"required": false\n` );
         wf( "-", `}\n` );

      wf( "-", `}\n`, "End bracket properties" );

   // *** End bracket FakeGato definition Block
   wf( "-", `}` );

   commaRequired_g = true;
}
function addIndividualCompleteAccessoryDefinitionBlocks( )
{
   wf( `"$comment": "START OF each accessories DEFINITION",\n` );
   // All the characteristics
   for ( let i=0; i < CMD4_DEVICE_TYPE_ENUM.EOL; i ++)
   {
      let devProps = CMD4_DEVICE_TYPE_ENUM.properties[ i ];
      let deviceName = CMD4_DEVICE_TYPE_ENUM.devEnumIndexToC( i );

      // add the comma always next time.
      if ( commaRequired_g == true )
         wf( `,\n` );

      wf( "+", `"${ deviceName }" :{\n` );
         wf( `"condition":\n` );
         wf( "+", `{\n` );
            wf( `"functionBody": "return ['${ deviceName }'].includes(model.type);"\n` );
         wf( "-", `},\n` );
         wf( "+", `"items": {\n` );

            wf( `"${ constants.TYPE }": { "$ref": "#/defs/${ deviceName }"},\n` );
            wf( `"name": { "$ref": "#/$defs/name"},\n` );
            wf( `"displayName": { "$ref": "#/$defs/displayName"},\n` );
            wf( `"subType": { "$ref": "#/$defs/subType"},\n` );

            wf( `"debug": { "$ref": "#/$defs/debug"},\n` );
            wf( `"publishExternally": { "$ref": "#/$defs/publishExternally"},\n` );
            wf( `"allowTLV8": { "$ref": "#/$defs/allowTLV8"},\n` );
            wf( `"outputConstants": { "$ref": "#/$defs/outputConstants"},\n` );
            wf( `"statusMsg": { "$ref": "#/$defs/statusMsg"},\n` );
            wf( `"interval": { "$ref": "#/$defs/interval"},\n` );
            wf( `"timeout": { "$ref": "#/$defs/timeout"},\n` );
            wf( `"stateChangeResponseTime": { "$ref": "#/$defs/stateChangeResponseTime"},\n` );
            wf( `"${ constants.QUEUE }": { "$ref": "#/$defs/queue"},\n` );

            devProps.requiredCharacteristics.forEach( ( reqProps ) =>
            {
               let characteristicString = CMD4_ACC_TYPE_ENUM.accEnumIndexToLC( reqProps.type );
               if ( characteristicString == "name" )
                  return;

               wf( `"${ characteristicString }": { "$ref": "#/$defs/${ characteristicString }"},\n` );
            });
            devProps.optionalCharacteristics.forEach( ( optPropIndex ) =>
            {
               let characteristicString = CMD4_ACC_TYPE_ENUM.accEnumIndexToLC( optPropIndex );
               if ( characteristicString == "name" )

                  return;
               wf( `"${ characteristicString }": { "$ref": "#/$defs/${ characteristicString }"},\n` );
            });

            // Create the polling optional characteristics for the device
            wf( `"${ constants.POLLING }": { "$ref": "#/$defs/polling"},\n` );
            wf( `"${ constants.STATE_CMD_PREFIX }": { "$ref": "#/$defs/state_cmd_prefix"},\n` );
            wf( `"${ constants.STATE_CMD }": { "$ref": "#/$defs/state_cmd"},\n` );
            wf( `"${ constants.STATE_CMD_SUFFIX }": { "$ref": "#/$defs/state_cmd_suffix"},\n` );
            wf( `"${ constants.FAKEGATO }": { "$ref": "#/$defs/fakegato"}` );

         wf( "-", `}\n` );
      // ** End device block
      wf( "-", `}` );

      commaRequired_g = true;
   }
}

function addAccessoryDefinitionBlock( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( `"$comment": "START OF accessories DEFINITION",\n` );

   // ** Begin bracket accessories block
   wf( "+", `"accessories": {\n` );
      wf( `"title": "Accessories",\n` );
      wf( `"type": "array",\n` );
      wf( `"uniqueItems": true,\n` );
      wf( "+", `"items": {\n` );

         wf( `"${ constants.TYPE }": { "$ref": "#/$defs/type"},\n` );

         // All the globals that can be defined at the Accessory level
         wf( `"debug": { "$ref": "#/$defs/debug"},\n` );
         wf( `"allowTLV8": { "$ref": "#/$defs/allowTLV8"},\n` );
         wf( `"outputConstants": { "$ref": "#/$defs/outputConstants"},\n` );
         wf( `"statusMsg": { "$ref": "#/$defs/statusMsg"},\n` );
         wf( `"interval": { "$ref": "#/$defs/interval"},\n` );
         wf( `"timeout": { "$ref": "#/$defs/timeout"},\n` );
         wf( `"stateChangeResponseTime": { "$ref": "#/$defs/stateChangeResponseTime"},\n` );

         wf( `"displayName": { "$ref": "#/$defs/displayName"},\n` );
         wf( `"subType": { "$ref": "#/$defs/subType"},\n` );

         // All the characteristics
         for ( let i=0; i < CMD4_ACC_TYPE_ENUM.EOL; i ++)
         {
            let properties = CMD4_ACC_TYPE_ENUM.properties[ i ];
            let characteristicString = properties.sche;

            wf( `"${ characteristicString }": { "$ref": "#/$defs/${ characteristicString }"},\n` );
         }

         wf( `"${ constants.QUEUE }": { "$ref": "#/$defs/queue"},\n` );
         wf( `"${ constants.POLLING }": { "$ref": "#/$defs/polling"},\n` );
         wf( `"${ constants.STATE_CMD_PREFIX }": { "$ref": "#/$defs/state_cmd_prefix"},\n` );
         wf( `"${ constants.STATE_CMD }": { "$ref": "#/$defs/state_cmd"},\n` );
         wf( `"${ constants.STATE_CMD_SUFFIX }": { "$ref": "#/$defs/state_cmd_suffix"}\n` );
      // *** End bracket items:
      wf( "-", `}\n` );
   // *** End bracket accessories:
   wf( "-", `}` );

   commaRequired_g = true;
}
/*

// Under defs  - Wrong ?
   "$defs":
   {
      "constants":
      { "type": "object",
        "properties":
        {
            "key": { "type": "string" },
            "value": { "type": "string" }
        }
      }
   },

// Under schema properties - Correct
 "properties": {
    "constants": { "$ref": "#/$defs/constants" },
    "debug":


// Under schema layout - Correct

  { "type": "flex", "flex-flow": "row wrap", "items": [ "constants.key", "constants.value" ] },

 */

/*   TRY 2
 ^\${[^}]*}:\s*"[^"]*"

     "$defs":
     {
        "constants":
        {
           "type": "array",
           "items": {
              "type": "object",
              "properties": {
                 "constants": { "type": "string",
                               "pattern": "^\${[^}]*}:\s*\"[^\"]*\""
                              }
              }
           }
        }
     },

     "constants": { "$ref": "#/$defs/constants" },

     { "key": "constants",
      "type": "section",
      "expandable": true,
      "items": [
      {
         "type": "array",
         "listItems": 1,
         "items": [ {
            "type": "div",
            "displayFlex": true,
            "flex-direction": "row",
            "items": [
            {  "key": "constants[]", "flex": "1 1 100px",
               "notitle": true, "placeholder": "\"${IP}\": \"192.16.100.2\""
            }]
         }]
      }]
    },

    "${IP}": "address",

 */
/*   TRY 3
 
 https://stackoverflow.com/questions/44052088/how-can-i-take-a-json-schema-that-can-build-a-form-with-dynamic-objects-in-addit
 https://hamidihamza.com/ajsf/?set=asf&example=asf-complex-key-support&framework=bootstrap-4&language=en


{
  "type": "object",
  "patternProperties": {
    "[/w/W]": {
       "type": "object"
    }
  }
}
 */
/*   TRY 4

 "schema": {
    "type": "object",
    "properties": {
       "constants":  {
          "type": "array",
          "items": {
             "type": "object",
             "properties": {
             }
          }
       },
       "first_name": { "type": "string" },


 "layout": [
 { "key": "constants",
   "type": "array",
   "listItems": 1,
   "items": [ {
      "type": "string",
      "displayFlex": true,
      "flex-direction": "row",
      "items": [
          { "key": "constants.", "flex": "4 4 200px",
            "notitle": true, "placeholder": "some constant"
          }
      ]
   }]
 },
 { "type": "flex", "flex-flow": "row wrap", "items": [ "first_name", "last_name" ] },



 "data": {
    "constants": [{"IP":"172"}],
    "first_name": "Jane",
 */
function addDefinitionBlock( )
{
   if ( commaRequired_g == true || commaRequired_g == false )
      return;

   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );
   wf( `"format":\n` );
   wf( "+", `{\n` );
      wf( `"title": "format",\n` );
      wf( `"description": "Characteristic Formats",\n` );
      wf( `"default": "string",\n` );
      wf( "+",`"oneOf": {\n` );
            wf( `{"Format": "boolean","enum": ["boolean"] },\n` );
            wf( `{"Format": "integer","enum": ["integer"] },\n` );
            wf( `{"Format": "number","enum": ["number"] },\n` );
            wf( `{"Format": "string","enum": ["string"] }\n` );
         wf( "-", `}` );
      wf( "-", `}` );
   wf( "-", `}` );

   wf( `"definitions":\n` );
   wf( "+", `{\n` );
      wf( `"title": "definitions",\n` );
      wf( `"description": "A New Characteristic Definition",\n` );
      wf( `"type": "array",\n` );
      wf( `"uniqueItems": true,\n` );
      wf( `"$comment": "This will have to Increase as each added are validated",\n` );
      wf( `"maxItems": 0,\n` );
      wf( `"required": false,\n` );
      wf( `"items":\n` );
      wf( "+", `{\n` );
         wf( `"type": "object",\n` );
         wf( `"properties":\n` );
         wf( "+", `{\n` );
           wf( `"format": { "$ref": "#/$defs/format"},\n` );
         wf( "-", `}` );
   wf( "-", `}` );

   commaRequired_g = true;
}


function addGlobalsDefinitionBlock( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

      wf( `"constants":\n` );
      wf( "+", `{\n` );
         wf( `"title": "constants",\n` );
         wf( `"description": "Constants that can be replaced within state_cmd_suffix",\n` );
         wf( `"required": false,\n` );
         wf( `"type": "array",\n` );
         wf( "+", `"items": {\n` );
            wf( `"type": "object",\n` );
            wf( "+", `"properties": {\n` );
               wf( "+", `"key": {\n` );
                  wf( `"type": "string",\n` );
                  wf( `"title": "key",\n` );
                  wf( `"description": "The constant to replace. i.e. \${IP}.",\n` );
                  // Must end up with     "pattern": "^\\${[\\w\\s]+}$",
                  wf( `"pattern": "^\\\\\${[\\\\w\\\\s]+}$",\n` );
                  wf( `"required": true\n` );
               wf( "-", `},\n` );
               wf( "+", `"value": {\n` );
                  wf( `"type": "string",\n` );
                  wf( `"title": "value",\n` );
                  wf( `"description": "The replacement string",\n` );
                  wf( `"required": true\n` );
               wf( "-", `}\n` );
            wf( "-", `}\n` );
         wf( "-", `}\n` );
      wf( "-", `},\n` );
      wf( `"debug":\n` );
      wf( "+", `{\n` );
         wf( `"title": "debug",\n` );
         wf( `"type": "boolean",\n` );
         wf( `"description": "Enables additional output in the log.",\n` );
         wf( `"required": false,\n` );
         wf( `"placeholder": false\n` );
      wf( "-", `},\n` );
      wf( `"statusMsg":\n` );
      wf( "+", `{\n` );
         wf( `"title": "statusMsg",\n` );
         wf( `"type": "boolean",\n` );
         wf( `"description": "Enables additional output in the log.",\n` );
         wf( `"required": false,\n` );
         wf( `"placeholder": true\n` );
      wf( "-", `},\n` );
      wf( `"allowTLV8":\n` );
      wf( "+", `{\n` );
         wf( `"title": "allowTLV8",\n` );
         wf( `"type": "boolean",\n` );
         wf( `"description": "Enables wacky TLV8 characteristics.",\n` );
         wf( `"required": false,\n` );
         wf( `"placeholder": false\n` );
      wf( "-", `},\n` );
      wf( `"outputConstants":\n` );
      wf( "+", `{\n` );
         wf( `"title": "outputConstants",\n` );
         wf( `"type": "boolean",\n` );
         wf( `"description": "Output constants instead of values.",\n` );
         wf( `"required": false,\n` );
         wf( `"placeholder": false\n` );
      wf( "-", `},\n` );
      wf( `"timeout":\n` );
      wf( "+", `{\n` );
         wf( `"title": "timeout",\n` );
         wf( `"type": "integer",\n` );
         wf( `"description": "The global timeout for all polling accessories (sec).",\n` );
         wf( `"required": false,\n` );
         wf( `"minimum": 3,\n` );
         wf( `"placeholder": 3\n` );
      wf( "-", `},\n` );
      wf( `"stateChangeResponseTime":\n` );
      wf( "+", `{\n` );
         wf( `"title": "stateChangeResponseTime",\n` );
         wf( `"type": "integer",\n` );
         wf( `"description": "The time for the accessories to respond (msec).",\n` );
         wf( `"required": false,\n` );
         wf( `"placeholder": 60000\n` );
      wf( "-", `},\n` );
      wf( `"interval":\n` );
      wf( "+", `{\n` );
         wf( `"title": "interval",\n` );
         wf( `"type": "integer",\n` );
         wf( `"description": "Polling interval of all accesssories (sec}.",\n` );
         wf( `"required": false,\n` );
         wf( `"minimum": 3,\n` );
         wf( `"placeholder": 60\n` );
      wf( "-", `},\n` );
      wf( `"state_cmd_prefix":\n` );
      wf( "+", `{\n` );
         wf( `"title": "state_cmd_prefix",\n` );
         wf( `"type": "string",\n` );
         wf( `"description": "The global state_cmd prefix for all accessories.",\n` );
         wf( `"required": false\n` );
      wf( "-", `},\n` );
      wf( `"state_cmd":\n` );
      wf( "+", `{\n` );
         wf( `"title": "state_cmd",\n` );
         wf( `"type": "string",\n` );
         wf( `"description": "The global state_cmd for all accessories.",\n` );
         wf( `"placeholder": ".homebridge/cmd4Scripts/",\n` );
         wf( `"required": false\n` );
      wf( "-", `},\n` );
      wf( `"state_cmd_suffix":\n` );
      wf( "+", `{\n` );
         wf( `"title": "state_cmd_suffix",\n` );
         wf( `"type": "string",\n` );
         wf( `"description": "The global state_cmd suffix for all accessories.",\n` );
         wf( `"required": false\n` );
      wf( "-", `},\n` );

      wf( `"definitions":\n` );
      wf( "+", `{\n` );
         wf( `"title": "definitions",\n` );
         wf( `"type": "object",\n` );
         wf( `"description": "complex data.",\n` );
         wf( `"required": false\n` );
      wf( "-", `},\n` );
      wf( `"queueTypes":\n` );
      wf( "+", `{\n` );
         wf( `"title": "queueTypes",\n` );
         wf( `"type": "array",\n` );
         wf( `"uniqueItems": true,\n` );
         wf( `"$comment": "This will have to Increase as each added are validated",\n` );
         wf( `"maxItems": 0,\n` );
         wf( `"required": false,\n` );
         wf( `"items":\n` );
         wf( "+", `{\n` );
            wf( `"type": "object",\n` );
            wf( `"properties":\n` );
            wf( "+", `{\n` );
               wf( `"queue":\n` );
               wf( "+", `{\n` );
                  wf( `"type": "string",\n` );
                  wf( `"required": true\n` );
               wf( "-", `},\n` );
               wf( `"queueType":\n` );
               wf( "+", `{\n` );
                  wf( `"type": "string",\n` );
                  wf( `"oneOf":\n` );
                  wf( "+", `[\n` );
                     wf( `{"title": "WoRm","enum": ["WoRm"] },\n` );
                     wf( `{ "title": "Sequential", "enum": ["Sequential" ]}\n` );
                 wf( "-", `]\n` );
             wf( "-", `}\n` );
         wf( "-", `}\n` );
      wf( "-", `}\n` );
   wf( "-", `}` );

   commaRequired_g = true;
}


function addCharacteristicDefinitionBlock( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( `"$comment": "START OF CHARACTERISTIC DEFINITIONS",\n` );
   // Over the Cmd4 Characteristics, create pre-definitions
   let characteristicCommaRequired = false;

   for ( let i=0; i < CMD4_ACC_TYPE_ENUM.EOL; i ++)
   {
      let conditionStarted = false;
      let properties = CMD4_ACC_TYPE_ENUM.properties[ i ];
      let characteristicString = properties.sche;
      let description = properties.description;
      let accProps = properties.props;

      // add the comma always next time.
      if ( characteristicCommaRequired == true )
         wf( `,\n` );

      // *** Begin bracket characteristic definition
      wf( `"${ characteristicString }":\n` );
      wf( "+", `{\n` );
         wf( `"title": "${ characteristicString }",\n` );
         switch ( accProps.format )
         {
            case hapFormats.BOOL:
               wf( `"type": "boolean",\n` );
               break;
            case hapFormats.INT:
            case hapFormats.UINT8:
            case hapFormats.UINT16:
            case hapFormats.UINT32:
            case hapFormats.UINT64:
               wf( `"type": "integer",\n` );
               break;
            case hapFormats.FLOAT:
               wf( `"type": "number",\n` );
               break;
            case hapFormats.STRING:
               wf( `"type": "string",\n` );
               break;
            case hapFormats.DATA:
            case hapFormats.TLV8:
            case hapFormats.DICT:
               wf( `"type": "string",\n` );
               break;
         }
         if ( accProps.minValue != undefined )
            wf( `"minimum": ${ accProps.minValue },\n` );
         if ( accProps.maxValue != undefined )
            wf( `"maximum": ${ accProps.maxValue },\n` );

         wf( `"description": "${ description }"` );

         for ( let j = 0; j < CMD4_DEVICE_TYPE_ENUM.EOL; j ++ )
         {
            let devProps = CMD4_DEVICE_TYPE_ENUM.properties[ j ];

            devProps.requiredCharacteristics.forEach( ( reqProps ) =>
            {
               if ( reqProps.type == i )
               {
                 if ( conditionStarted == false )
                 {

                    // dtart bracket condition
                    wf( `,\n` );
                    wf( `"condition":\n` );
                    wf( "+", `{\n` );
                        wf( `"functionBody": "return ['${ devProps.deviceName }'`);
                    conditionStarted = true;
                 } else
                 {
                         wf( `,'${ devProps.deviceName }'`);
                 }
              }
           });
         }
         if ( conditionStarted == true )
         {
            if ( accProps.format == hapFormats.TLV8 )
            {
               wf( `].includes(model.type) && model.allowTLV8 == true;"\n`);
            } else
            {
               wf( `].includes(model.type);"\n`);
            }
            // ***End bracket condition
            wf( "-", `}\n` );
         } else
         {
             wf( `\n`);
         }

         // *** End bracket characteristic definition
      wf( "-", `}` );

      characteristicCommaRequired = true;
   }

   commaRequired_g = true;
}

function beginSchemaProperties( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   // ** Begin bracket properties
   wf( `"properties":\n` );
   wf( "+", `{\n` );

   commaRequired_g = false;
}
function endSchemaProperties( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `\n` );

   // *** End bracket properties:
   wf( "-", `}\n` );

   commaRequired_g = true;
}

function addGlobalsSchemaBlockForSchema( forSchema )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   // All the globals that can be used at the Accessory level
   wf( `"debug": { "$ref": "#/$defs/debug"},\n` );

   if ( forSchema != "Accessory" )
      wf( `"constants": { "$ref": "#/$defs/constants"},\n` );

   if ( forSchema == "Accessory" )
   {
      wf( `"publishAccessory": { "$ref": "#/$defs/publishAccessory"},\n` );
   }

   wf( `"allowTLV8": { "$ref": "#/$defs/allowTLV8"},\n` );
   wf( `"outputConstants": { "$ref": "#/$defs/outputConstants"},\n` );
   wf( `"statusMsg": { "$ref": "#/$defs/statusMsg"},\n` );
   wf( `"interval": { "$ref": "#/$defs/interval"},\n` );
   wf( `"timeout": { "$ref": "#/$defs/timeout"},\n` );
   wf( `"stateChangeResponseTime": { "$ref": "#/$defs/stateChangeResponseTime"}` );

   if ( forSchema != "Accessory" )
   {
      wf( `,\n` );
      wf( `"queueTypes": { "$ref": "#/$defs/queueTypes"}` );
   }

   commaRequired_g = true;
}

function addCharacteristicsSchemaBlock( )
{
   // All the characteristics
   for ( let i=0; i < CMD4_ACC_TYPE_ENUM.EOL; i ++)
   {
      // add the comma always next time.
      if ( commaRequired_g == true )
         wf( `,\n` );

      let properties = CMD4_ACC_TYPE_ENUM.properties[ i ];
      let characteristicString = properties.sche;

      wf( `"${ characteristicString }": { "$ref": "#/$defs/${ characteristicString }"}` );

      commaRequired_g = true;
   }
}

function addQueueSchemaBlock( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( `"${ constants.QUEUE }": { "$ref": "#/$defs/queue"}` );

   commaRequired_g = true;
}

function addPollingSchemaBlock( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( `"${ constants.POLLING }": { "$ref": "#/$defs/polling"}` );

   commaRequired_g = true;
}

function addStateCmdSchemaBlock( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( `"${ constants.STATE_CMD_PREFIX }": { "$ref": "#/$defs/state_cmd_prefix"},\n` );
   wf( `"${ constants.STATE_CMD }": { "$ref": "#/$defs/state_cmd"},\n` );
   wf( `"${ constants.STATE_CMD_SUFFIX }": { "$ref": "#/$defs/state_cmd_suffix"}` );

   commaRequired_g = true;
}

function addFakeGatoSchemaBlock( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( `"${ constants.FAKEGATO }": { "$ref": "#/$defs/fakegato"}` );

   commaRequired_g = true;
}

// $$$$$$$$  LAYOUT  $$$$$$$$$$

function addConditionalLayoutForDeviceType( )
{
   for ( let index=0; index < CMD4_DEVICE_TYPE_ENUM.EOL; index ++)
   {
      if ( commaRequired_g == true )
         wf( `,\n` );

      let deviceName = CMD4_DEVICE_TYPE_ENUM.properties[ index ].deviceName;


      wf( "+", `{\n` );
      wf( `"key": "${ deviceName }",\n` );
         wf( `"title": "${ deviceName } Options",\n` );
         wf( `"condition":\n` );
         wf( "+", `{\n` );
            wf( `"functionBody": "return ['${ deviceName }'].includes(model.type);"\n` );
         wf( "-", `},\n` );
         wf( `"type": "fieldset",\n` );
         wf( `"expandable": true,\n` );
         wf( `"items":\n` );
         wf( "+", `[\n` );
            commaRequired_g = false;
            addGlobalsLayoutForSchema( "Accessory" );
            addPollingLayout( );
            addStateCmdLayoutForSchema( );
            addFakeGatoLayout( );
         wf( "-", `]\n` );
      wf( "-", `}` );
   }

   commaRequired_g = true;
}

function addTypeLayout( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

      wf( "+", `{\n` );
        wf( `"key": "${ constants.TYPE }",\n` );
        wf( `"$ref": "#/$defs/type"\n` );
      wf( "-", `}` );

   commaRequired_g = true;
}

function addNameLayout( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( "+", `{\n` );
     wf( `"key": "name",\n` );
     wf( `"condition":\n` );
     wf( "+", `{\n` );
        wf( `"functionBody": "return model.type && model.type !== 'null';"\n` );
     wf( "-", `}\n` );
   wf( "-", `}` );

   commaRequired_g = true;
}

/*
function addPublishExternallyLayout( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( "+", `{\n` );
     wf( `"publishExternally": {"$ref": "#/defs/publishExternally"}\n` );
   wf( "-", `}` );

   commaRequired_g = true;
}
*/

function addGlobalsLayoutForSchema( forSchema )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( "+", `{\n` );
      wf( `"title": "${ forSchema } Options",\n` );
      wf( `"type": "fieldset",\n` );
      wf( `"expandable": true,\n` );
      wf( `"items":\n` );
      wf( "+", `[\n` );
         wf( `"debug",\n` );

         if ( forSchema == "Global" )
         {
            wf( "+", `{\n` );
               wf( `"title": "${ forSchema } Constants",\n` );
               wf( `"type": "fieldset",\n` );
               wf( `"expandable": true,\n` );
               wf( "+", `"items": [ {\n` );
                  wf( `"key": "constants",\n` );
                  wf( `"type": "array",\n` );
                  wf( `"uniqueItems": true,\n` );
                  wf( `"listItems": "3",\n` );
                  wf( "+", `"items": [ {\n` );
                     wf( `"type": "div",\n` );
                     wf( `"displayFlex": true,\n` );
                     wf( `"flex-direction": "row",\n` );
                     wf( "+", `"items": [\n` );
                        wf( "+", `{\n` );
                            wf( `"key": "constants[].key", "flex": "1 1 100px",\n` );
                            wf( `"title": "key", "placeholder": "i.e. \${IP}"\n` );
                        wf( "-", `},\n` );
                        wf( "+", `{\n` );
                            wf( `"key": "constants[].value", "flex": "4 4 150px",\n` );
                            wf( `"title": "value", "placeholder": "i.e. 192.168.x.x"\n` );
                        wf( "-", `}\n` );
                     wf( "-", `]\n` );
                  wf( "-", `} ]\n` );
               wf( "-", `} ]\n` );
            wf( "-", `},\n` );
         }
         if ( forSchema == "Accessory" )
            wf( `"publishExternally",\n` );

         wf( `"statusMsg",\n` );
         wf( `"allowTLV8",\n` );
         wf( `"outputConstants",\n` );
         wf( `"timeout",\n` );
         wf( `"stateChangeResponseTime",\n` );
         wf( `"interval"\n` );
      wf( "-", `]\n` );
   wf( "-", `}` );

   commaRequired_g = true;
}


function addStateCmdLayoutForSchema( forSchema = null )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( "+", `{\n` );
      if ( forSchema == null )
         wf( `"title": "state_cmd Options",\n` );
      else
         wf( `"title": "${ forSchema } state_cmd Options",\n` );
      wf( `"type": "fieldset",\n` );
      wf( `"expandable": true,\n` );
      wf( `"items":\n` );
      wf( "+", `[\n` );
         wf( `"state_cmd_prefix",\n` );
         wf( `"state_cmd",\n` );
         wf( `"state_cmd_suffix"\n` );
      wf( "-", `]\n` );
   wf( "-", `}` );

   commaRequired_g = true;
}

function addFakeGatoLayout( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( "+", `{\n` );
      wf( `"title": "FakeGato Options",\n` );
      wf( `"type": "fieldset",\n` );
      wf( `"expandable": true,\n` );
      wf( `"items":\n` );
      wf( "+", `[\n` );
         wf( "+", `{\n` );
            wf( `"key": "fakegato.storage", "flex": "1 1 50px",\n` );
            wf( `"notitle": false, "placeholder": "fs"\n` );
         wf( "-", `},\n` );
         wf( "+", `{\n` );
            wf( `"key": "fakegato.storagePath", "flex": "1 1 50px",\n` );
            wf( `"notitle": false\n` );
         wf( "-", `},\n` );
         wf( "+", `{\n` );
            wf( `"key": "fakegato.folder", "flex": "1 1 50px",\n` );
            wf( `"notitle": false\n` );
         wf( "-", `},\n` );
         wf( "+", `{\n` );
            wf( `"key": "fakegato.keyPath", "flex": "1 1 50px",\n` );
            wf( `"notitle": false\n` );
         wf( "-", `}\n` );
      wf( "-", `]\n` );
   wf( "-", `}` );

   commaRequired_g = true;
}

function addRequiredCharacteristicPerDeviceLayout( )
{

   wf( `"$comment": "START OF REQUIRED CHARACTERISTIC LAYOUT PER DEVICE BLOCK",\n` );


   // Over the Cmd4 Devices, create pre-definitions
   for ( let index=0; index < CMD4_DEVICE_TYPE_ENUM.EOL; index ++ )
   {
      let properties = CMD4_DEVICE_TYPE_ENUM.properties[ index ];
      let deviceName = properties.deviceName;
      let requiredCharacteristics = properties.requiredCharacteristics;
      let requireStarted  = false;

      requiredCharacteristics.forEach( ( entry ) =>
      {
         // add the comma always next time.
         if ( commaRequired_g == true )
         {
             wf( `,\n` );
            commaRequired_g = false;
         }
         let requiredCharacteristic = CMD4_ACC_TYPE_ENUM.accEnumIndexToLC( entry.type );
         // add the comma always next time.
         if ( requireStarted == false )
         {
            requireStarted = true;

            wf( "+", `{\n` );
               wf( `"type": "fieldset",\n`);
               wf( `"expandable": true,\n`);
               wf( `"title": "${ deviceName } Required Characteristics",\n`);
               wf( `"condition":\n` );
               wf( "+", `{\n` );
                  wf( `"functionBody": "return ['${ deviceName }'].includes(model.type);"\n` );
               wf( "-", `},\n` );
               wf( `"items":\n` );
               wf( "+", `[\n` );
                  wf( `"${ requiredCharacteristic }"` );
          } else
          {
                  wf( `,"${ requiredCharacteristic }"` );
          }
      })
      if ( requireStarted == true )
      {
               wf( `\n` );
               wf( "-", `]\n` );
             wf( "-", `}` );

             commaRequired_g = true;
      }

   }

   commaRequired_g = true;
}

function addOptionalCharacteristicPerDeviceLayout( )
{

   wf( `"$comment": "START OF REQUIRED CHARACTERISTIC LAYOUT PER DEVICE BLOCK",\n` );


   // Over the Cmd4 Devices, create pre-definitions
   for ( let index=0; index < CMD4_DEVICE_TYPE_ENUM.EOL; index ++ )
   {
      let properties = CMD4_DEVICE_TYPE_ENUM.properties[ index ];
      let deviceName = properties.deviceName;
      let optionalCharacteristics = properties.optionalCharacteristics;
      let optionalStarted  = false;

      optionalCharacteristics.forEach( ( entry ) =>
      {
         // add the comma always next time.
         if ( commaRequired_g == true )
         {
             wf( `,\n` );
            commaRequired_g = false;
         }
         let optionalCharacteristic = CMD4_ACC_TYPE_ENUM.accEnumIndexToLC( entry );
         // add the comma always next time.
         if ( optionalStarted == false )
         {
            optionalStarted = true;

            wf( "+", `{\n` );
               wf( `"type": "fieldset",\n`);
               wf( `"expandable": true,\n`);
               wf( `"title": "${ deviceName } Optional Characteristics",\n`);
               wf( `"condition":\n` );
               wf( "+", `{\n` );
                  wf( `"functionBody": "return ['${ deviceName }'].includes(model.type);"\n` );
               wf( "-", `},\n` );
               wf( `"items":\n` );
               wf( "+", `[\n` );
                  wf( `"${ optionalCharacteristic }"` );
          } else
          {
                  wf( `,"${ optionalCharacteristic }"` );
          }
      })
      if ( optionalStarted == true )
      {
               wf( `\n` );
               wf( "-", `]\n` );
             wf( "-", `}` );

             commaRequired_g = true;
      }

   }

   commaRequired_g = true;
}

function addQueueTypesLayoutForSchema( forSchema = null )
{
   wf( `"$comment": "START OF QUEUE TYPES LAYOUT BLOCK",\n` );

   // add the comma always next time.
   if ( commaRequired_g == true )
   {
      wf( `,\n` );
      commaRequired_g = false;
   }

   wf( "+", `{\n` );
      if ( forSchema == null )
         wf( `"title": "QueueTypes",\n` );
      else
         wf( `"title": "${ forSchema } QueueTypes",\n` );

      wf( `"type": "fieldset",\n` );
      wf( `"expandable": true,\n` );
      wf( "+", `"items": [ {\n` );
         wf( `"key": "queueTypes",\n` );
         wf( `"$ref": "#/$defs/queueTypes",\n` );
         wf( `"type": "array",\n` );
         wf( `"uniqueItems": true,\n` );
         wf( `"listItems": "3",\n` );
         wf( "+", `"items": [ {\n` );
            wf( `"type": "div",\n` );
            wf( `"displayFlex": true,\n` );
            wf( `"flex-direction": "row",\n` );
            wf( "+", `"items": [\n` );
               wf( "+", `{\n` );
                   wf( `"key": "queueTypes[].queue", "flex": "1 1 50px",\n` );
                   wf( `"notitle": false, "placeholder": "AQueueName"\n` );
               wf( "-", `},\n` );
               wf( "+", `{\n` );
                   wf( `"key": "queueTypes[].queueType", "flex": "4 4 200px",\n` );
                   wf( `"notitle": false, "placeholder": "WoRm"\n` );
               wf( "-", `}\n` );
            wf( "-", `]\n` );
         wf( "-", `} ]\n` );
      wf( "-", `} ]\n` );
   wf( "-", `}` );

   commaRequired_g = true;
}

function addPollingLayout( )
{
   wf( `"$comment": "START OF POLLING LAYOUT BLOCK",\n` );

   // add the comma always next time.
   if ( commaRequired_g == true )
   {
      wf( `,\n` );
      commaRequired_g = false;
   }

   wf( "+", `{\n` );
      wf( `"title": "Polling",\n` );
      wf( `"type": "fieldset",\n` );
      wf( `"expandable": true,\n` );
      wf( "+", `"items": [ {\n` );
         wf( `"key": "polling",\n` );
         wf( `"$ref": "#/$defs/polling",\n` );
         wf( `"type": "array",\n` );
         wf( `"uniqueItems": true,\n` );
         wf( `"listItems": "3",\n` );
         wf( "+", `"items": [ {\n` );
            wf( `"type": "div",\n` );
            wf( `"displayFlex": true,\n` );
            wf( `"flex-direction": "row",\n` );
            wf( "+", `"items": [\n` );
               wf( "+", `{\n` );
                   wf( `"key": "polling[].characteristic", "flex": "3 3 auto",\n` );
                   wf( `"notitle": false, "placeholder": "a characteristic"\n` );
               wf( "-", `},\n` );
               wf( "+", `{\n` );
                   wf( `"key": "polling[].timeout", "flex": "1 1 auto",\n` );
                   wf( `"notitle": false, "placeholder": "3000"\n` );
               wf( "-", `},\n` );
               wf( "+", `{\n` );
                   wf( `"key": "polling[].interval", "flex": "1 1 auto",\n` );
                   wf( `"notitle": false, "placeholder": "180"\n` );
               wf( "-", `},\n` );
               wf( "+", `{\n` );
                   wf( `"key": "polling[].stateChangeResponseTime", "flex": "2 2 auto",\n` );
                   wf( `"notitle": false, "placeholder": "5000"\n` );
               wf( "-", `}\n` );
            wf( "-", `]\n` );
         wf( "-", `} ]\n` );
      wf( "-", `} ]\n` );
   wf( "-", `}` );

   commaRequired_g = true;
}

// $$$$$$$$$$$$$$$$$$$$$$$$$$$$


function endBracketSchema( )
{
   // * End bracket Schema
   wf( "-", `}` );

   commaRequired_g = true;
}

function closeSchemaDocument( )
{
   // End bracket JSON
   // For vi % balance: {
   wf( "-", `}\n` );

   // Close the Schema file
   fs.closeSync( fid );

   // After it is closed, check if it was properly aligned
   if ( bracketLevel == 0)
       console.log( `Yahoo !  Bracket Level All lined up.` );
   else
      console.log( `Booo ... alignment failed: [ ${ Number(bracketLevel > 0) + bracketLevel } ]` );

   // Check if finished properly with closing bracket
   if (  validator_g == validatorStates.CLOSED_SQUIGGLY_BRACKET_HANGING )
      console.log( `Yahoo !  Finished with closing bracket.` );
   else
      console.log( `Booo ... validator left hanging ${ validator_g }` );
}

function testGeneratedSchema( )
{
   var Validator = require('jsonschema').Validator;
   let v = new Validator();
   let schemaFile = `${ CMD4_BASE_PATH }/CMD4_SCHEMA_FILE }`;
   let schema_in = fs.readFileSync( schemaFile, 'utf8' );
   let schema = JSON.parse( schema_in );
   let dataFile =  `${ CMD4_BASE_PATH }/${ CMD4_CONFIG_FILE }`;
   let data_in = fs.readFileSync( dataFile, 'utf8' );
   let DATA = JSON.parse( data_in );
   console.log( v.validate( DATA, schema ));

}


// Write to fid the given text, increasing or decreasing bracketLevel.
function wf( level, text = undefined, comment = undefined )
{
   if ( text == undefined )
   {
      text = level;
      level = undefined;
   }

   // Ignore comments that are only available in version 7+
   if ( schemaVersionSupport <= 6 && text.startsWith( `"$comment"` ) )
      return;


   // Subtract now
   switch( level )
   {
      case "-":

         bracketLevel--;

         if ( bracketLevel < 0 )
            throw new Error( `two many closed braces ${ bracketLevel } for text: ${ text }` );

         //  match exactly 1 of either CLOSED_SQUIGGLY_BRACKET or : or ]
         //  optionally followed by 0 or 1 commas
         //  followed by 0 or more newline characters
         //  at end of line
         //  // For vi % balance: {[
         if ( text.match( /[}\]]{1}[,]?\n*$/ ) )
         {
            // noop
         } else
            // For vi % balance: {
            // The schema.js files close with };
            // For vi % balance: {
            if ( level == "-" && text.match( /};\n*$/ ) )
            {
               // noop
            } else
               throw new Error ( `Invalid text for closed level. text: ${ text }` );
         break;
      case "+":
         //  match exactly 1 of either OPEN_SQUIGGLY_BRACKET or : or [
         //  followed by 0 or more spaces
         //  followed by 0 or more newline characters
         //  at end of line

         if ( text.match( /[{:[]{1}\s*[\n]*$/ ) ) // For vi % balance: ]}
         {
            // noop
         } else
            throw new Error ( `Invalid text for open level. text: ${ text }` );
         break;
      case undefined:
         // No level passed in
         break;
      default:
         throw new Error ( `Invalid level: ${ level }` );
   }


   // Validate actual text, not just spaces and a newline
   if ( text.match( /\S[\n]{1}$/ ) )
   {
      // Based on the set validator_g, the text must contain ...
      switch( validator_g )
      {
         case validatorStates.COLON_HANGING:
         {
            // must start with " or { or [
            // For vi % balance: }]
            if ( text.match( /^\s*["{[]{1}/ ) ) // for vi % balance: ]}
            {
               // noop
            } else
               throw new Error( `With COLON_HANGING next char must be " or { or [ for text: ${ text }\npreviousText: ${ previousText }` );
            break;
         }
         case validatorStates.COMMA_HANGING:
         {
            if ( text.match( /^\s*,/ ) )
               throw new Error( `With COMMA_HANGING next char Cannot be a , text: ${ text }\npreviousText: ${ previousText }` );

            // must start with " or {
            // For vi % balance: }
            if ( text.match( /^\s*["{]{1}/ ) ) // for vi % balance: }
            {
               // noop
            } else
               throw new Error( `With COMMA_HANGING next char must be " or { for text: ${ text }\npreviousText: ${ previousText }` );
            break;
         }
         case validatorStates.CLOSED_SQUARE_BRACKET_HANGING:
         {
            // For vi % balance: {
            // must start with } or .
            // For vi % balance: {
            if ( text.match( /^\s*[}\\.]{1}/ ) )
            {
               // noop
            } else
               throw new Error( `With CLOSED_SQUARE_BRACKET_HANGING next char must be } or . for text: ${ text }\npreviousText: ${ previousText }` );
            break;
         }
         case validatorStates.OPEN_SQUARE_BRACKET_HANGING:
         {
            // must start with " or { or '
            if ( text.match( /^\s*["{']{1}/ ) ) // for vi % balance: }}
            {
               // noop
            } else
               throw new Error( `With OPEN_SQUARE_BRACKET_HANGING next char must be " or { or ' for text: ${ text }\npreviousText: ${ previousText }` );
            break;
         }
         case validatorStates.CLOSED_ROUND_BRACKET_HANGING:
         {
            // must start with & or ;
            if ( text.match( /^\s*[&;]{1}/ ) )
            {
               // noop
            } else
               throw new Error( `With CLOSED_ROUND_BRACKET_HANGING next char must be & or ; for text: ${ text }\npreviousText: ${ previousText }` );
            break;
         }
         case validatorStates.OPEN_ROUND_BRACKET_HANGING:
         {
            // must start with model
            if ( text.match( /^\s*model/ ) )
            {
               // noop
            } else
               throw new Error( `With OPEN_ROUND_BRACKET_HANGING next char must be 'model' for text: ${ text }\npreviousText: ${ previousText }` );
            break;
         }
         case validatorStates.CLOSED_SQUIGGLY_BRACKET_HANGING:
         {
            // for vi % balance: {
            // must start with , } "
            // for vi % balance: {
            if ( text.match( /^\s*[,}]{1}/ ) )
            {
               // noop
            } else
            {
               // for vi % balance: {
               if ( level == "-" &&
                    text.match( /^\s*[}\]]{1}/ ) )
               {
                  // A level change with a } or ] bracket is okay

                  // noop
               } else
               {
                  throw new Error( `With CLOSED_SQUIGGLY_BRACKET_HANGING: next char must be , or } or " for text: ${ text }\npreviousText: ${ previousText }` );
               }
            }
            break;
         }
         case validatorStates.OPEN_SQUIGGLY_BRACKET_HANGING:
         {
            // must start with  "
            if ( text.match( /^\s*["]{1}/ ) )
            {
               // noop
            } else
               throw new Error( `With OPEN_SQUIGGLY_BRACKET_HANGING: next char must be " for text: ${ text }\npreviousText: ${ previousText }` );
            break;
         }

         case validatorStates.DOUBLE_QUOTES_HANGING:
         {
            // must start with a-zA-Z:,
            if ( text.match( /^\s*[a-zA-Z:,]/ ) )
            {
               // noop
            } else
               throw new Error( `With DOUBLE_QUOTES_HANGING next char must be " or a-zA-Z:i or , for text: ${ text }\npreviousText: ${ previousText }` );
            break;
         }
         case validatorStates.CLEAR:
         default:
      }
   }

   // Anything not previously a new line gets indented
   if ( previousText.match( /\n$/ ) )
   {
      fs.writeSync( fid, " ".repeat( bracketLevel * INDENT ).concat( text ) );
   } else
   {
      fs.writeSync( fid, text );
   }
   // Ignore comments that are only available in version 7+
   if ( schemaVersionSupport >= 7 && comment != undefined )
      fs.writeSync( fid, `"$comment": "${comment}"\n` );


   // ******** UPDATE VALIDATOR FOR NEXT WRITE OF TEXT

   //  match exactly 1 of comma
   //    [1]{1}
   //  followed by 0 or more spaces
   //    [,]{1}\s*
   //  followed by 0 or more newline characters
   //    [,]{1}\s*[\n]*
   //  at end of line
   //    [,]{1}\s*[\n]*$
   //
   if ( text.match( /[,]{1}\s*[\n]*$/ ) )
   {
      validator_g = validatorStates.COMMA_HANGING;
   } else if ( text.match( /[:]{1}\s*[\n]*$/ ) )
   {
      validator_g = validatorStates.COLON_HANGING;
   } else if ( text.match( /[\]]{1}\s*[\n]*$/ ) )
   {
      validator_g = validatorStates.CLOSED_SQUARE_BRACKET_HANGING;
   } else if ( text.match( /[)]{1}\s*[\n]*$/ ) )
   {
      validator_g = validatorStates.CLOSED_ROUND_BRACKET_HANGING;
   } else if ( text.match( /[(]{1}\s*[\n]*$/ ) )
   {
      validator_g = validatorStates.OPEN_ROUND_BRACKET_HANGING;
   } else if ( text.match( /[[]{1}\s*[\n]*$/ ) )
   {
      validator_g = validatorStates.OPEN_SQUARE_BRACKET_HANGING;
   } // For vi % balance: {
   else if ( text.match( /[}]{1}\s*[\n]*$/ ) )
   {
      validator_g = validatorStates.CLOSED_SQUIGGLY_BRACKET_HANGING;
   } else if ( text.match( /[{]{1}\s*[\n]*$/ ) ) // For vi % balance: }
   {
      validator_g = validatorStates.OPEN_SQUIGGLY_BRACKET_HANGING;
   } else {
      validator_g = validatorStates.NONE_FOUND;
   }

   previousText = text;

   // Add later
   if ( level == "+" )
      bracketLevel++;
}

// MAIN STUFF STARTS HERE

getHomebridgeVars( );

// Init the library for all to use
CMD4_ACC_TYPE_ENUM.init( _api.hap );
CMD4_DEVICE_TYPE_ENUM.init( _api.hap, _api.hap.Service );

// Command line parser
const { Command } = require( "commander" );
const program = new Command;

// A nice little getOpt node.js package
program
  .description( 'Generate Cmd4 config.schema.json and associated .js files if requested' )
  //.requiredOption( '-c, --constant <constant value>', 'Constant to search for>' )

  .option( '-g, --globals', `Create the globalsSchema.js file` )
  .option( '-a, --accessory', `Create the accessorySchema.js file.` )
  .option( '-b, --base', `base Path to read/write config files from.\nDefault: ${ CMD4_BASE_PATH }` )
  .option( '-t, --test', `test against our config.json` );


// Parse the arguments passed into this program.
program.parse( process.argv );

// Get the options passed in based on the commander getOpts definitions.
let options = program.opts( );

if ( options.base )
   CMD4_BASE_PATH = options.base;

console.log( `basePath: ${ CMD4_BASE_PATH }` );

// Always create the config.schema.json file
createSchemaFile( );

// Create the accessorySchema.js file
if ( options.accessory )
{
   createAccessorySchemaFile( );
   createAccessorySchemaFile2( );
}
// Create the globalsSchema.js file
if ( options.globals )
   createGlobalsSchemaFile( );

if ( options.test )
   testGeneratedSchema( );

// The bracket level is a good indication of overall success
return bracketLevel;
