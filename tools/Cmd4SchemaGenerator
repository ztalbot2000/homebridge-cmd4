#!/usr/bin/env node


// Cmd4 Constants and Settings
const constants = require( "../cmd4Constants" );
const settings = require( "../cmd4Settings" );
const path = require( "path" );
let fs = require( "fs" );

//const CMD4_SCHEMA_FILE = "./config.schema.json";
const CMD4_CONFIG_FILE = "./Extras/config.json";
const CMD4_SCHEMA_FILE = "/usr/local/lib/node_modules/homebridge-cmd4/config.schema.json";

const schemaVersionSupport = 6;
let _api;
let hapFormats;


// These would be the uninitialized values.
let CMD4_ACC_TYPE_ENUM = require( '../lib/CMD4_ACC_TYPE_ENUM' );
let CMD4_DEVICE_TYPE_ENUM = require( '../lib/CMD4_DEVICE_TYPE_ENUM' );

// Formatting stuff
var fid;
var bracketLevel=0;
const INDENT = 3;
var commaRequired_g = false;
var previousText = "";
var validatorStates = { CLEAR: 0,
                        COMMA_HANGING: 1,
                        COLON_HANGING: 2,
                        OPEN_ROUND_BRACKET_HANGING: 3,
                        CLOSED_ROUND_BRACKET_HANGING: 4,
                        OPEN_SQUARE_BRACKET_HANGING: 5,
                        CLOSED_SQUARE_BRACKET_HANGING: 6,
                        OPEN_SQUIGGLY_BRACKET_HANGING: 7,
                        CLOSED_SQUIGGLY_BRACKET_HANGING: 8,
                        DOUBLE_QUOTE_HANGING: 9,
                        NONE_FOUND: 10
                      };
var validator_g = validatorStates.CLEAR;

function getHomebridgeVars( )
{
   const which = require('which');
   let apiPath;
   let HomebridgeAPI;

   // Get the real path of homebridge instead of a dev dependancy,
   // which caused issues if you forget to update dependancies but
   // upgrade homebridge.
   const homebridgePath = which.sync( 'homebridge', { nothrow: true } )

   if ( homebridgePath )
   {
      let dirname = path.dirname( homebridgePath );

      console.log( "Found homebridge in path %s", dirname );
      apiPath = `${ dirname }/../lib/node_modules/homebridge/lib/api`;
      HomebridgeAPI = require( apiPath ).HomebridgeAPI;

      if ( ! HomebridgeAPI )
      {
         console.log( "homebridgeAPI not available !!!" );
         process.exit( 10 );
      }

   } else
   {
      console.log( "homebridge not found !!!" );
      process.exit( 10 );
   }
   console.log( "Found api in %s", apiPath );

   _api = new HomebridgeAPI( ); // object we feed to Plugins
   hapFormats = _api.hap.Formats;
}

function createSchemaFile( )
{
   // Open the Schema file for writing
   fid = fs.createWriteStream( CMD4_SCHEMA_FILE,
   { flags: "w" // Open for write
   });
   console.log( `Creating Schema file: ${ CMD4_SCHEMA_FILE }` );

   fid.on("error", ( err ) =>
   {
      console.log( "dserror: %s", err );
      process.exit( err );
   });

   commaRequired_g = false;
   addSchemaHeader( );

   startSchema( );

   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   // ** Begin bracket definitions
   wf( `"$definitions":\n` );
   wf( "+", `{\n` );

      commaRequired_g = false;
      addGlobalsDefinitionBlock( );
      addCharacteristicDefinitionBlock( );
      addAccessoryTypeDefinitionBlock( );
      addSubTypeDefinitionBlock( );
      addDisplayNameDefinitionBlock( );
      addPollingDefinitionBlock( );
      addAccessoryDefinitionBlock( );

   // ** End bracket definitions
   wf( `\n` );
   wf( "-", `}` );

   commaRequired_g = true;

   addAccessorySchemaBlock( );

   endBracketSchema( );

   addLayout( );

   closeSchemaDocument( );

   // After it is closed, check if it was properly aligned
   if ( bracketLevel == 0)
   {
      console.log( `Yahoo !  All lined up.` );
   } else
   {
      console.log( `Booo ... alignment failed: [ ${ Number(bracketLevel > 0) + bracketLevel } ]` );
   }
   if (  validator_g == validatorStates.REQUIRED )
   {
      console.log( `Yahoo !  No hanging commas.` );
   } else
   {
      console.log( `Booo ... comma left hanging ${ validator_g }` );
   }
}

//
// Write the beginning blurb
//
function  addSchemaHeader( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   // Begin bracket JSON
   wf( "+", `{\n` );   // For vi % balance: }

   // pluginAlias: The plugin identifier.
   wf( `"pluginAlias": "${ settings.PLATFORM_NAME }",\n` );

   // pluginType: The type of plugin, valid values are platform or accessory.
   wf( `"pluginType": "platform",\n` );

   // headerDisplay: Additional content in the user interface above the config form.
   wf( `"headerDisplay": "Cmd4 Add Accessories",\n` );

   // footerDisplay: Additional content in the user interface below the config form.
   // wf( `"footerDisplay": "A Sample Footer for Cmd4",\n` );

   // singular: If set to true the UI will not allow the user to add
   // more than one config block. This is usually used for platform
   // plugins where only a single config block should be present.
   wf( `"singular": false,` );
   wf( `"customUi": true` );

   commaRequired_g = true;
}

function startSchema( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   // * Begin bracket Schema
   wf( `"schema":\n` );
   wf( "+", `{\n` );   // For vi % balance: }
   //w ( `"schema": "https://json-schema.org/draft/2020-12/schema",\n`);

   commaRequired_g = false;
}

function addSubTypeDefinitionBlock( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( `"$comment": "START OF subType DEFINITION",\n` );
   // *** Begin bracket subType designation definition
   wf( `"subType":\n` );
   wf( "+", `{\n` );
      wf( `"$id": "#subType",\n` );
      wf( `"type": "string",\n` );
      wf( `"title": "subType",\n` );
      wf( `"description": "The accessories subType.",\n` );
      wf( `"placeholder": "A secondary name",\n` );
      wf( `"required": false\n` );
   wf( "-", `}`, "end bracket subType designation" );

   commaRequired_g = true;
}

function addDisplayNameDefinitionBlock( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( `"$comment": "START OF displayName DEFINITION",\n` );
   // *** Begin bracket displayName designation definition
   wf( `"displayName":\n` );
   wf( "+", `{\n` );
      wf( `"$id": "#displayName",\n` );
      wf( `"type": "string",\n` );
      wf( `"title": "displayName",\n` );
      wf( `"description": "The accessories display name.",\n` );
      wf( `"placeholder": "My_Device",\n` );
      wf( `"required": true\n` );
   wf( "-", `}`, "end bracket displayName designation" );

   commaRequired_g = true;
}


function addAccessoryTypeDefinitionBlock( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( `"$comment": "START OF type DEFINITION",\n` );
   // *** Begin bracket Type designation definition
   wf( `"type":\n` );
   wf( "+", `{\n` );
      wf( `"$id": "#type",\n` );
      wf( `"type": "string",\n` );
      wf( `"title": "${ constants.TYPE }",\n` );
      wf( `"description": "Select the Accessory Type.",\n` );
      wf( `"default": "Switch",\n` );
      // **** Begin square bracket oneOf for "type"
      wf( `"oneOf":\n` );
      wf( "+", `[\n` );
         //Example: { "title": "Switch", "enum": ["Switch"] },

         // Over the Cmd4 Devices
         let deviceCommaRequired = false;
         for ( let index=0; index < CMD4_DEVICE_TYPE_ENUM.EOL; index ++)
         //for ( let j=0; j < devices.length; j++ )
         {
             if ( deviceCommaRequired == true )
                 wf(",\n");

             //let index = devices[ j ];
             let deviceName = CMD4_DEVICE_TYPE_ENUM.properties[ index ].deviceName;
             wf( `{ "title": "${ deviceName }", "enum": ["${ deviceName }"] }` );

             deviceCommaRequired = true ;
         }
         wf( "\n" );
      wf( "-", `],\n`, "end square bracket oneOf" );
      wf( `"required": true\n` );
   wf( "-", `}`, "end bracket Type designation" );

   commaRequired_g = true;
}

function addPollingDefinitionBlock( )
{
   console.log("*****validator_g: %s", validator_g );
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );
   console.log("*****validator_g: %s", validator_g );

   wf( `"$comment": "START OF polling DEFINITION",\n` );
   // *** Begin bracket Polling designation definition
   wf( `"polling":\n` );
   wf( "+", `{\n` );
      wf( `"$id": "#polling",\n` );
      wf( `"title": "${ constants.POLLING }",\n` );
      wf( `"type": "array",\n` );
      wf( `"required": false,\n` );
      wf( `"uniqueItems": true,\n` );
      wf( `"$comment": "This will have to Increase as each added are validated",\n` );
      wf( `"maxItems": 0,\n` );
      wf( `"items":\n`);
      wf( "+", `{\n`);
         wf( `"type": "object",\n` );
         wf( `"properties":\n` );
         wf( "+", `{\n` );
            wf( `"characteristic":\n` );
            wf( "+", `{\n` );
               wf( `"title": "characteristic",\n` );
               wf( `"type": "string",\n` );
               wf( `"required": "true"\n` );
            wf( "-", `},` );
            wf( `"interval":\n` );
            wf( "+", `{\n` );
               wf( `"title": "interval",\n` );
               wf( `"type": "number",\n` );
               wf( `"required": "false"\n` );
            wf( "-", `},` );
            wf( `"stateChaneResponseTime":\n` );
            wf( "+", `{\n` );
               wf( `"title": "stateChaneResponseTime",\n` );
               wf( `"type": "number",\n` );
               wf( `"required": "false"\n` );
            wf( "-", `},` );
            wf( `"queue":\n` );
            wf( "+", `{\n` );
               wf( `"title": "queue",\n` );
               wf( `"type": "string",\n` );
               wf( `"required": "false"\n` );
            wf( "-", `}\n` );
         wf( "-", `}\n` );
      wf( "-", `}\n` );
   // *** End bracket Polling designation definition
   wf( "-", `}` );

   commaRequired_g = true;
}

function addAccessoryDefinitionBlock( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( `"$comment": "START OF accessories DEFINITION",\n` );

   // ** Begin bracket accessories definition block
   wf( "+", `"accessories": {\n` );
      wf( `"$id": "#accessories",\n` );
      wf( `"title": "Accessories",\n` );
      wf( `"type": "array",\n` );
      wf( `"uniqueItems": true,\n` );
      wf( "+", `"items": {\n` );

         wf( `"${ constants.TYPE }": { "$ref": "#/$definitions/type"},\n` );

         // All the globals that can be defined at the Accessory level
         wf( `"debug": { "$ref": "#/$definitions/debug"},\n` );
         wf( `"allowTLV8": { "$ref": "#/$definitions/allowTLV8"},\n` );
         wf( `"outputConstants": { "$ref": "#/$definitions/outputConstants"},\n` );
         wf( `"statusMsg": { "$ref": "#/$definitions/statusMsg"},\n` );
         wf( `"interval": { "$ref": "#/$definitions/interval"},\n` );
         wf( `"timeout": { "$ref": "#/$definitions/timeout"},\n` );
         wf( `"stateChangeResponseTime": { "$ref": "#/$definitions/stateChangeResponseTime"},\n` );
         wf( `"queueTypes": { "$ref": "#/$definitions/queueTypes"},\n` );

         wf( `"folder": { "$ref": "#/$definitions/folder"},\n` );
         wf( `"storage": { "$ref": "#/$definitions/storage"},\n` );
         wf( `"storagePath": { "$ref": "#/$definitions/storagePath"},\n` );
         wf( `"keyPath": { "$ref": "#/$definitions/keyPath"},\n` );
         wf( `"displayName": { "$ref": "#/$definitions/displayName"},\n` );
         wf( `"subType": { "$ref": "#/$definitions/subType"},\n` );

         // All the characteristics
         for ( let i=0; i < CMD4_ACC_TYPE_ENUM.EOL; i ++)
         {
            let properties = CMD4_ACC_TYPE_ENUM.properties[ i ];
            let characteristicString = properties.sche;

            wf( `"${ characteristicString }": { "$ref": "#/$definitions/${ characteristicString }"},\n` );
         }

         wf( `"${ constants.POLLING }": { "$ref": "#/$definitions/polling"},\n` );
         wf( `"${ constants.STATE_CMD_PREFIX }": { "$ref": "#/$definitions/state_cmd_prefix"},\n` );
         wf( `"${ constants.STATE_CMD }": { "$ref": "#/$definitions/state_cmd"},\n` );
         wf( `"${ constants.STATE_CMD_SUFFIX }": { "$ref": "#/$definitions/state_cmd_suffix"}\n` );
      // *** End bracket items:
      wf( "-", `}\n` );
   // *** End bracket accessories:
   wf( "-", `}` );

   commaRequired_g = true;
}


function addGlobalsDefinitionBlock( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

      wf( `"debug":\n` );
      wf( "+", `{\n` );
         wf( `"title": "debug",\n` );
         wf( `"type": "boolean",\n` );
         wf( `"description": "Enables additional output in the log.",\n` );
         wf( `"required": false,\n` );
         wf( `"placeholder": false\n` );
      wf( "-", `},\n` );
      wf( `"statusMsg":\n` );
      wf( "+", `{\n` );
         wf( `"title": "statusMsg",\n` );
         wf( `"type": "boolean",\n` );
         wf( `"description": "Enables additional output in the log.",\n` );
         wf( `"required": false,\n` );
         wf( `"placeholder": true\n` );
      wf( "-", `},\n` );
      wf( `"allowTLV8":\n` );
      wf( "+", `{\n` );
         wf( `"title": "allowTLV8",\n` );
         wf( `"type": "boolean",\n` );
         wf( `"description": "Enables wacky TLV8 characteristics.",\n` );
         wf( `"required": false,\n` );
         wf( `"placeholder": false\n` );
      wf( "-", `},\n` );
      wf( `"outputConstants":\n` );
      wf( "+", `{\n` );
         wf( `"title": "outputConstants",\n` );
         wf( `"type": "boolean",\n` );
         wf( `"description": "Output constants instead of values.",\n` );
         wf( `"required": false,\n` );
         wf( `"placeholder": false\n` );
      wf( "-", `},\n` );
      wf( `"timeout":\n` );
      wf( "+", `{\n` );
         wf( `"title": "timeout",\n` );
         wf( `"type": "integer",\n` );
         wf( `"description": "The global timeout for all polling accessories (sec).",\n` );
         wf( `"required": false,\n` );
         wf( `"minimum": 3,\n` );
         wf( `"placeholder": 3\n` );
      wf( "-", `},\n` );
      wf( `"stateChangeResponseTime":\n` );
      wf( "+", `{\n` );
         wf( `"title": "stateChangeResponseTime",\n` );
         wf( `"type": "integer",\n` );
         wf( `"description": "The time for the accessories to respond (msec).",\n` );
         wf( `"required": false,\n` );
         wf( `"placeholder": 60000\n` );
      wf( "-", `},\n` );
      wf( `"interval":\n` );
      wf( "+", `{\n` );
         wf( `"title": "interval",\n` );
         wf( `"type": "integer",\n` );
         wf( `"description": "Polling interval of all accesssories (sec}.",\n` );
         wf( `"required": false,\n` );
         wf( `"minimum": 3,\n` );
         wf( `"placeholder": 60\n` );
      wf( "-", `},\n` );
      wf( `"state_cmd_prefix":\n` );
      wf( "+", `{\n` );
         wf( `"title": "state_cmd_prefix",\n` );
         wf( `"type": "string",\n` );
         wf( `"description": "The global state_cmd prefix for all accessories.",\n` );
         wf( `"required": false\n` );
      wf( "-", `},\n` );
      wf( `"state_cmd":\n` );
      wf( "+", `{\n` );
         wf( `"title": "state_cmd",\n` );
         wf( `"type": "string",\n` );
         wf( `"description": "The global state_cmd for all accessories.",\n` );
         wf( `"placeholder": ".homebridge/cmd4Scripts/",\n` );
         wf( `"required": false\n` );
      wf( "-", `},\n` );
      wf( `"state_cmd_suffix":\n` );
      wf( "+", `{\n` );
         wf( `"title": "state_cmd_suffix",\n` );
         wf( `"type": "string",\n` );
         wf( `"description": "The global state_cmd suffix for all accessories.",\n` );
         wf( `"required": false\n` );
      wf( "-", `},\n` );
      wf( `"storage":\n` );
      wf( "+", `{\n` );
         wf( `"title": "storage",\n` );
         wf( `"description": "The FakeGato Storage type for all accessories.",\n` );
         wf( `"required": false,\n` );
         wf( `"type": "string",\n` );
         wf( `"oneOf":\n`);
         wf( "+", `[\n` );
           wf( `{"title": "fs","enum": ["fs"] },\n` );
           wf( `{ "title": "googleDrive", "enum": ["googleDrive" ]}\n` );
         wf( "-", `]\n` );
      wf( "-", `},\n` );
      wf( `"storagePath":\n` );
      wf( "+", `{\n` );
         wf( `"title": "storagePath",\n` );
         wf( `"type": "string",\n` );
         wf( `"description": "The global FakeGato storagePath for all accessories.",\n` );
         wf( `"required": false\n` );
      wf( "-", `},\n` );
      wf( `"folder":\n` );
      wf( "+", `{\n` );
         wf( `"title": "folder",\n` );
         wf( `"type": "string",\n` );
         wf( `"description": "The global FakeGato folder for all accessories.",\n` );
         wf( `"required": false\n` );
      wf( "-", `},\n` );
      wf( `"keyPath":\n` );
      wf( "+", `{\n` );
         wf( `"title": "keyPath",\n` );
         wf( `"type": "string",\n` );
         wf( `"description": "The FakeGato keyPath for all accessories.",\n` );
         wf( `"required": false\n` );
      wf( "-", `},\n` );
      wf( `"definitions":\n` );
      wf( "+", `{\n` );
         wf( `"title": "definitions",\n` );
         wf( `"type": "object",\n` );
         wf( `"description": "complex data.",\n` );
         wf( `"required": false\n` );
      wf( "-", `},\n` );
      wf( `"queueTypes":\n` );
      wf( "+", `{\n` );
         wf( `"title": "queueTypes",\n` );
         wf( `"type": "array",\n` );
         wf( `"uniqueItems": true,\n` );
         wf( `"$comment": "This will have to Increase as each added are validated",\n` );
         wf( `"maxItems": 0,\n` );
         wf( `"required": false,\n` );
         wf( `"items":\n` );
         wf( "+", `{\n` );
            wf( `"type": "object",\n` );
            wf( `"properties":\n` );
            wf( "+", `{\n` );
               wf( `"queue":\n` );
               wf( "+", `{\n` );
                  wf( `"type": "string",\n` );
                  wf( `"required": true\n` );
               wf( "-", `},\n` );
               wf( `"queueType":\n` );
               wf( "+", `{\n` );
                  wf( `"type": "string",\n` );
                  wf( `"oneOf":\n` );
                  wf( "+", `[\n` );
                     wf( `{"title": "WoRm","enum": ["WoRm"] },\n` );
                     wf( `{ "title": "Sequential", "enum": ["Sequential" ]}\n` );
                 wf( "-", `]\n` );
             wf( "-", `}\n` );
         wf( "-", `}\n` );
      wf( "-", `}\n` );
   wf( "-", `}` );


   commaRequired_g = true;
}


function addCharacteristicDefinitionBlock( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( `"$comment": "START OF CHARACTERISTIC DEFINITIONS",\n` );
   // Over the Cmd4 Characteristics, create pre-definitions
   let characteristicCommaRequired = false;

   for ( let i=0; i < CMD4_ACC_TYPE_ENUM.EOL; i ++)
   {
      let conditionStarted = false;
      let properties = CMD4_ACC_TYPE_ENUM.properties[ i ];
      let characteristicString = properties.sche;
      let description = properties.description;
      let accProps = properties.props;

      // add the comma always next time.
      if ( characteristicCommaRequired == true )
         wf( `,\n` );

      // *** Begin bracket characteristic definition
      wf( `"${ characteristicString }":\n` );
      wf( "+", `{\n` );
         wf( `"$id": "#${ characteristicString }",\n` );
         wf( `"title": "${ characteristicString }",\n` );
         switch ( accProps.format )
         {
            case hapFormats.BOOL:
               wf( `"type": "boolean",\n` );
               break;
            case hapFormats.INT:
            case hapFormats.UINT8:
            case hapFormats.UINT16:
            case hapFormats.UINT32:
            case hapFormats.UINT64:
               wf( `"type": "integer",\n` );
               break;
            case hapFormats.FLOAT:
               wf( `"type": "number",\n` );
               break;
            case hapFormats.STRING:
               wf( `"type": "string",\n` );
               break;
            case hapFormats.DATA:
            case hapFormats.TLV8:
            case hapFormats.DICT:
               wf( `"type": "string",\n` );
               break;
         }
         if ( accProps.minValue != undefined )
            wf( `"minimum": ${ accProps.minValue },\n` );
         if ( accProps.maxValue != undefined )
            wf( `"maximum": ${ accProps.maxValue },\n` );

         wf( `"description": "${ description }"` );

         for ( let j = 0; j < CMD4_DEVICE_TYPE_ENUM.EOL; j ++ )
         {
            let devProps = CMD4_DEVICE_TYPE_ENUM.properties[ j ];

            devProps.requiredCharacteristics.forEach( ( reqProps ) =>
            {
               if ( reqProps.type == i )
               {
                 if ( conditionStarted == false )
                 {

                    // dtart bracket condition
                    wf( `,\n` );
                    wf( `"condition":\n` );
                    wf( "+", `{\n` );
                        wf( `"functionBody": "return ['${ devProps.deviceName }'`);
                    conditionStarted = true;
                 } else
                 {
                         wf( `,'${ devProps.deviceName }'`);
                 }
              }
           });
         }
         if ( conditionStarted == true )
         {
            if ( accProps.format == hapFormats.TLV8 )
            {
               wf( `].includes(model.type) && model.allowTLV8 == true;"\n`);
            } else
            {
               wf( `].includes(model.type);"\n`);
            }
            // ***End bracket condition
            wf( "-", `}\n` );
         } else
         {
             wf( `\n`);
         }

         // *** End bracket characteristic definition
      wf( "-", `}` );

      characteristicCommaRequired = true;
   }

   commaRequired_g = true;
}


function addAccessorySchemaBlock( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   // ** Begin bracket properties
   wf( `"properties":\n` );
   wf( "+", `{\n` );
//    wf( `"${ constants.TYPE }": { "$ref": "#/$definitions/type"},\n` );

      // All the globals that can be defined at the Accessory level
      wf( `"debug": { "$ref": "#/$definitions/debug"},\n` );
      wf( `"allowTLV8": { "$ref": "#/$definitions/allowTLV8"},\n` );
      wf( `"outputConstants": { "$ref": "#/$definitions/outputConstants"},\n` );
      wf( `"statusMsg": { "$ref": "#/$definitions/statusMsg"},\n` );
      wf( `"interval": { "$ref": "#/$definitions/interval"},\n` );
      wf( `"timeout": { "$ref": "#/$definitions/timeout"},\n` );
      wf( `"stateChangeResponseTime": { "$ref": "#/$definitions/stateChangeResponseTime"},\n` );
      wf( `"queueTypes": { "$ref": "#/$definitions/queueTypes"},\n` );

      wf( `"folder": { "$ref": "#/$definitions/folder"},\n` );
      wf( `"storage": { "$ref": "#/$definitions/storage"},\n` );
      wf( `"storagePath": { "$ref": "#/$definitions/storagePath"},\n` );
      wf( `"keyPath": { "$ref": "#/$definitions/keyPath"},\n` );

      // All the characteristics
      for ( let i=0; i < CMD4_ACC_TYPE_ENUM.EOL; i ++)
      {
         let properties = CMD4_ACC_TYPE_ENUM.properties[ i ];
         let characteristicString = properties.sche;

         wf( `"${ characteristicString }": { "$ref": "#/$definitions/${ characteristicString }"},\n` );
      }

      wf( `"${ constants.POLLING }": { "$ref": "#/$definitions/polling"},\n` );
      wf( `"${ constants.STATE_CMD_PREFIX }": { "$ref": "#/$definitions/state_cmd_prefix"},\n` );
      wf( `"${ constants.STATE_CMD }": { "$ref": "#/$definitions/state_cmd"},\n` );
      wf( `"${ constants.STATE_CMD_SUFFIX }": { "$ref": "#/$definitions/state_cmd_suffix"}\n` );
   // *** End bracket properties:
   wf( "-", `}\n` );

   commaRequired_g = true;
}


// $$$$$$$$  LAYOUT  $$$$$$$$$$

function addTypeLayout( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

      wf( "+", `{\n` );
        wf( `"key": "${ constants.TYPE }",\n` );
        wf( `"$ref": "#/$definitions/type"\n` );
      wf( "-", `}` );

   commaRequired_g = true;
}

function addNameLayout( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( "+", `{\n` );
     wf( `"key": "name",\n` );
     wf( `"condition":\n` );
     wf( "+", `{\n` );
        wf( `"functionBody": "return model.type && model.type !== 'null';"\n` );
     wf( "-", `}\n` );
   wf( "-", `}` );

   commaRequired_g = true;
}

function addGlobalsLayout( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( "+", `{\n` );
      wf( `"title": "Accessory Options",\n` );
      wf( `"type": "fieldset",\n` );
      wf( `"expandable": true,\n` );
      wf( "+", `"items": [\n` );
//    wf( `"items":\n` );
//    wf( "+", `[\n` );
         wf( `"debug",\n` );
         wf( `"statusMsg",\n` );
         wf( `"allowTLV8",\n` );
         wf( `"outputConstants",\n` );
         wf( `"timeout",\n` );
         wf( `"stateChangeResponseTime",\n` );
         wf( `"interval"\n` );
      wf( "-", `]\n` );
   wf( "-", `}` );

   commaRequired_g = true;
}


function addStateCmdLayout( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( "+", `{\n` );
      wf( `"title": "state_cmd Options",\n` );
      wf( `"type": "fieldset",\n` );
      wf( `"expandable": true,\n` );
      wf( `"items":\n` );
      wf( "+", `[\n` );
         wf( `"state_cmd_prefix",\n` );
         wf( `"state_cmd",\n` );
         wf( `"state_cmd_suffix"\n` );
      wf( "-", `]\n` );
   wf( "-", `}` );

   commaRequired_g = true;
}


function addFakeGatoLayout( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   wf( "+", `{\n` );
      wf( `"title": "FakeGato Options",\n` );
      wf( `"type": "fieldset",\n` );
      wf( `"expandable": true,\n` );
      wf( `"items":\n` );
      wf( "+", `[\n` );
         wf( "+", `{\n` );
            wf( `"key": "storage", "flex": "1 1 50px",\n` );
            wf( `"notitle": false, "placeholder": "fs"\n` );
         wf( "-", `},\n` );
         wf( "+", `{\n` );
            wf( `"key": "storagePath", "flex": "1 1 50px",\n` );
            wf( `"notitle": false\n` );
         wf( "-", `},\n` );
         wf( "+", `{\n` );
            wf( `"key": "folder", "flex": "1 1 50px",\n` );
            wf( `"notitle": false\n` );
         wf( "-", `},\n` );
         wf( "+", `{\n` );
            wf( `"key": "keyPath", "flex": "1 1 50px",\n` );
            wf( `"notitle": false\n` );
         wf( "-", `}\n` );
      wf( "-", `]\n` );
   wf( "-", `}` );

   commaRequired_g = true;
}

function addRequiredCharacteristicPerDeviceLayout( )
{

   wf( `"$comment": "START OF REQUIRED CHARACTERISTIC LAYOUT PER DEVICE BLOCK",\n` );


   // Over the Cmd4 Devices, create pre-definitions
   for ( let index=0; index < CMD4_DEVICE_TYPE_ENUM.EOL; index ++ )
   {
      let properties = CMD4_DEVICE_TYPE_ENUM.properties[ index ];
      let deviceName = properties.deviceName;
      let requiredCharacteristics = properties.requiredCharacteristics;
      let requireStarted  = false;

      requiredCharacteristics.forEach( ( entry ) =>
      {
         // add the comma always next time.
         if ( commaRequired_g == true )
         {
             wf( `,\n` );
            commaRequired_g = false;
         }
         let requiredCharacteristic = CMD4_ACC_TYPE_ENUM.accEnumIndexToLC( entry.type );
         // add the comma always next time.
         if ( requireStarted == false )
         {
            requireStarted = true;

            wf( "+", `{\n` );
               wf( `"type": "fieldset",\n`);
               wf( `"expandable": true,\n`);
               wf( `"title": "${ deviceName } Required Characteristics",\n`);
               wf( `"condition":\n` );
               wf( "+", `{\n` );
                  wf( `"functionBody": "return ['${ deviceName }'].includes(model.type);"\n` );
               wf( "-", `},\n` );
               wf( `"items":\n` );
               wf( "+", `[\n` );
                  wf( `"${ requiredCharacteristic }"` );
          } else
          {
                  wf( `,"${ requiredCharacteristic }"` );
          }
      })
      if ( requireStarted == true )
      {
               wf( `\n` );
               wf( "-", `]\n` );
             wf( "-", `}` );

             commaRequired_g = true;
      }

   }

   commaRequired_g = true;
}

function addOptionalCharacteristicPerDeviceLayout( )
{

   wf( `"$comment": "START OF REQUIRED CHARACTERISTIC LAYOUT PER DEVICE BLOCK",\n` );


   // Over the Cmd4 Devices, create pre-definitions
   for ( let index=0; index < CMD4_DEVICE_TYPE_ENUM.EOL; index ++ )
   {
      let properties = CMD4_DEVICE_TYPE_ENUM.properties[ index ];
      let deviceName = properties.deviceName;
      let optionalCharacteristics = properties.optionalCharacteristics;
      let optionalStarted  = false;

      optionalCharacteristics.forEach( ( entry ) =>
      {
         // add the comma always next time.
         if ( commaRequired_g == true )
         {
             wf( `,\n` );
            commaRequired_g = false;
         }
         let optionalCharacteristic = CMD4_ACC_TYPE_ENUM.accEnumIndexToLC( entry );
         // add the comma always next time.
         if ( optionalStarted == false )
         {
            optionalStarted = true;

            wf( "+", `{\n` );
               wf( `"type": "fieldset",\n`);
               wf( `"expandable": true,\n`);
               wf( `"title": "${ deviceName } Optional Characteristics",\n`);
               wf( `"condition":\n` );
               wf( "+", `{\n` );
                  wf( `"functionBody": "return ['${ deviceName }'].includes(model.type);"\n` );
               wf( "-", `},\n` );
               wf( `"items":\n` );
               wf( "+", `[\n` );
                  wf( `"${ optionalCharacteristic }"` );
          } else
          {
                  wf( `,"${ optionalCharacteristic }"` );
          }
      })
      if ( optionalStarted == true )
      {
               wf( `\n` );
               wf( "-", `]\n` );
             wf( "-", `}` );

             commaRequired_g = true;
      }

   }

   commaRequired_g = true;
}


function addQueueTypesLayout( )
{
   wf( `"$comment": "START OF QUEUE TYPES LAYOUT BLOCK",\n` );

   // add the comma always next time.
   if ( commaRequired_g == true )
   {
      wf( `,\n` );
      commaRequired_g = false;
   }

   wf( "+", `{\n` )
     wf( `"key": "queueTypes",\n` );
     wf( `"$ref": "#/$definitions/queueTypes",\n` );
     wf( `"type": "array",\n` );
     wf( `"listItems": 1,\n` );
     wf( `"items":\n` );
     wf( "+", `[\n` );
        wf( "+", `{\n` );
           wf( `"type": "div",\n` );
           wf( `"displayFlex": true,\n` );
           wf( `"flex-direction": "row",\n` );
           wf( `"items":\n` );
           wf( "+", `[\n` );
              wf( "+", `{\n` );
                  wf( `"key": "queueTypes[].queue", "flex": "1 1 50px",\n` );
                  wf( `"notitle": false, "placeholder": "AQueueName"\n` );
               wf( "-", `},\n` );
               wf( "+", `{\n` );
                 wf( `"key": "queueTypes[].queueType", "flex": "4 4 200px",\n` );
                 wf( `"notitle": false, "placeholder": "WoRm"\n` );
               wf( "-", `}\n` );
            wf( "-", `]\n` );
         wf( "-", `}\n` );
      wf( "-", `]\n` );
   wf( "-", `}` );

   commaRequired_g = true;
}

// $$$$$$$$$$$$$$$$$$$$$$$$$$$$


function endBracketSchema( )
{
   // * End bracket Schema
   wf( "-", `}` );

   commaRequired_g = true;
}

function addLayout( )
{
   // add the comma always next time.
   if ( commaRequired_g == true )
      wf( `,\n` );

   // * Begin square bracket layout:
   wf( `"layout":\n` );
   wf( "+", `[\n` );

      commaRequired_g = false;

      addTypeLayout( );
      addNameLayout( );
      addGlobalsLayout( );
      addFakeGatoLayout( );
      addQueueTypesLayout( );
      addRequiredCharacteristicPerDeviceLayout( );
      addOptionalCharacteristicPerDeviceLayout( );
      addStateCmdLayout( );

   // * End square bracket layout:
   wf( "-", `]\n` );

   commaRequired_g = true;
}

function closeSchemaDocument( )
{
   // End bracket JSON
   // For vi % balance: {
   wf( "-", `}\n` );

   // Close the Schema file
   fid.end( );
}

function testGeneratedSchema( )
{
   var Validator = require('jsonschema').Validator;
   let v = new Validator();
   let schema_in = fs.readFileSync( CMD4_SCHEMA_FILE, 'utf8' );
   let schema = JSON.parse( schema_in );
   let data_in = fs.readFileSync( CMD4_CONFIG_FILE, 'utf8' );
   let DATA = JSON.parse( data_in );
   console.log( v.validate( DATA, schema ));

}


// Write to fid the given text, increasing or decreasing bracketLevel.
function wf( level, text = undefined, comment = undefined )
{
   if ( text == undefined )
   {
      text = level;
      level = undefined;
   }

   // Ignore comments that are only available in version 7+
   if ( schemaVersionSupport <= 6 && text.startsWith( `"$comment"` ) )
      return;


   // Subtract now
   switch( level )
   {
      case "-":

         bracketLevel--;

         if ( bracketLevel < 0 )
            throw new Error( `two many closed braces ${ bracketLevel } for text: ${ text }` );

         //  match exactly 1 of either CLOSED_SQUIGGLY_BRACKET or : or ]
         //  optionally followed by 0 or 1 commas
         //  followed by 0 or more newline characters
         //  at end of line
         //  // For vi % balance: {[
         if ( text.match( /[}\]]{1}[,]?\n*$/ ) )
         {
            // noop
         } else
            throw new Error ( `Invalid text for closed level. text: ${ text }` );
         break;
      case "+":
         //  match exactly 1 of either OPEN_SQUIGGLY_BRACKET or : or [
         //  followed by 0 or more spaces
         //  followed by 0 or more newline characters
         //  at end of line

         if ( text.match( /[{:[]{1}\s*[\n]*$/ ) ) // For vi % balance: ]}
         {
            // noop
         } else
            throw new Error ( `Invalid text for open level. text: ${ text }` );
         break;
      case undefined:
         // No level passed in
         break;
      default:
         throw new Error ( `Invalid level: ${ level }` );
   }


   // Validate actual text, not just spaces and a newline
   if ( text.match( /\S[\n]{1}$/ ) )
   {
      // Based on the set validator_g, the text must contain ...
      switch( validator_g )
      {
         case validatorStates.COLON_HANGING:
         {
            // must start with " or { or [
            // For vi % balance: }]
            if ( text.match( /^\s*["{[]{1}/ ) ) // for vi % balance: ]}
            {
               // noop
            } else
               throw new Error( `With COLON_HANGING next char must be " or { or [ for text: ${ text }\npreviousText: ${ previousText }` );
            break;
         }
         case validatorStates.COMMA_HANGING:
         {
            // must start with " or {
            // For vi % balance: }
            if ( text.match( /^\s*["{]{1}/ ) ) // for vi % balance: }
            {
               // noop
            } else
               throw new Error( `With COMMA_HANGING next char must be " or { for text: ${ text }\npreviousText: ${ previousText }` );
            break;
         }
         case validatorStates.CLOSED_SQUARE_BRACKET_HANGING:
         {
            // For vi % balance: {
            // must start with } or .
            // For vi % balance: {
            if ( text.match( /^\s*[}\\.]{1}/ ) )
            {
               // noop
            } else
               throw new Error( `With CLOSED_SQUARE_BRACKET_HANGING next char must be } or . for text: ${ text }\npreviousText: ${ previousText }` );
            break;
         }
         case validatorStates.OPEN_SQUARE_BRACKET_HANGING:
         {
            // must start with " or { or '
            if ( text.match( /^\s*["{']{1}/ ) ) // for vi % balance: }}
            {
               // noop
            } else
               throw new Error( `With OPEN_SQUARE_BRACKET_HANGING next char must be " or { or ' for text: ${ text }\npreviousText: ${ previousText }` );
            break;
         }
         case validatorStates.CLOSED_ROUND_BRACKET_HANGING:
         {
            // must start with & or ;
            if ( text.match( /^\s*[&;]{1}/ ) )
            {
               // noop
            } else
               throw new Error( `With CLOSED_ROUND_BRACKET_HANGING next char must be & or ; for text: ${ text }\npreviousText: ${ previousText }` );
            break;
         }
         case validatorStates.OPEN_ROUND_BRACKET_HANGING:
         {
            // must start with model
            if ( text.match( /^\s*model/ ) )
            {
               // noop
            } else
               throw new Error( `With OPEN_ROUND_BRACKET_HANGING next char must be 'model' for text: ${ text }\npreviousText: ${ previousText }` );
            break;
         }
         case validatorStates.CLOSED_SQUIGGLY_BRACKET_HANGING:
         {
            // for vi % balance: {
            // must start with , } "
            // for vi % balance: {
            if ( text.match( /^\s*[,}]{1}/ ) )
            {
               // noop
            } else
            {
               // for vi % balance: {
               if ( level == "-" &&
                    text.match( /^\s*[}\]]{1}/ ) )
               {
                  // A level change with a } or ] bracket is okay

                  // noop
               } else
               {
                  throw new Error( `With CLOSED_SQUIGGLY_BRACKET_HANGING: next char must be , or } or " for text: ${ text }\npreviousText: ${ previousText }` );
               }
            }
            break;
         }
         case validatorStates.OPEN_SQUIGGLY_BRACKET_HANGING:
         {
            // must start with  "
            if ( text.match( /^\s*["]{1}/ ) )
            {
               // noop
            } else
               throw new Error( `With OPEN_SQUIGGLY_BRACKET_HANGING: next char must be " for text: ${ text }\npreviousText: ${ previousText }` );
            break;
         }

         case validatorStates.DOUBLE_QUOTES_HANGING:
         {
            // must start with a-zA-Z:,
            if ( text.match( /^\s*[a-zA-Z:,]/ ) )
            {
               // noop
            } else
               throw new Error( `With DOUBLE_QUOTES_HANGING next char must be " or a-zA-Z:i or , for text: ${ text }\npreviousText: ${ previousText }` );
            break;
         }
         case validatorStates.CLEAR:
         default:
      }
   }

   // Anything not previously a new line gets indented
   if ( previousText.match( /\n$/ ) )
   {
      fid.write( " ".repeat( bracketLevel * INDENT ).concat( text ) );
   } else
   {
      fid.write( text );
   }
   // Ignore comments that are only available in version 7+
   if ( schemaVersionSupport >= 7 && comment != undefined )
      fid.write( `"$comment": "${comment}"\n` );


   // ******** UPDATE VALIDATOR FOR NEXT WRITE OF TEXT

   //  match exactly 1 of comma
   //    [1]{1}
   //  followed by 0 or more spaces
   //    [,]{1}\s*
   //  followed by 0 or more newline characters
   //    [,]{1}\s*[\n]*
   //  at end of line
   //    [,]{1}\s*[\n]*$
   //
   if ( text.match( /[,]{1}\s*[\n]*$/ ) )
   {
      validator_g = validatorStates.COMMA_HANGING;
   } else if ( text.match( /[:]{1}\s*[\n]*$/ ) )
   {
      validator_g = validatorStates.COLON_HANGING;
   } else if ( text.match( /[\]]{1}\s*[\n]*$/ ) )
   {
      validator_g = validatorStates.CLOSED_SQUARE_BRACKET_HANGING;
   } else if ( text.match( /[)]{1}\s*[\n]*$/ ) )
   {
      validator_g = validatorStates.CLOSED_ROUND_BRACKET_HANGING;
   } else if ( text.match( /[(]{1}\s*[\n]*$/ ) )
   {
      validator_g = validatorStates.OPEN_ROUND_BRACKET_HANGING;
   } else if ( text.match( /[[]{1}\s*[\n]*$/ ) )
   {
      validator_g = validatorStates.OPEN_SQUARE_BRACKET_HANGING;
   } // For vi % balance: {
   else if ( text.match( /[}]{1}\s*[\n]*$/ ) )
   {
      validator_g = validatorStates.CLOSED_SQUIGGLY_BRACKET_HANGING;
   } else if ( text.match( /[{]{1}\s*[\n]*$/ ) ) // For vi % balance: }
   {
      validator_g = validatorStates.OPEN_SQUIGGLY_BRACKET_HANGING;
   } else {
      validator_g = validatorStates.NONE_FOUND;
   }

   previousText = text;

   // Add later
   if ( level == "+" )
      bracketLevel++;
}

// MAIN STUFF STARTS HERE

getHomebridgeVars( );

// Init the library for all to use
CMD4_ACC_TYPE_ENUM.init( _api.hap );
CMD4_DEVICE_TYPE_ENUM.init( _api.hap, _api.hap.Service );

// Command line parser
const { Command } = require( "commander" );
const program = new Command;

// A nice little getOpt node.js package
program
  .description( 'Generate Cmd4 cinfig.schema.json' )
  //.requiredOption( '-c, --constant <constant value>', 'Constant to search for>' )

  .option( '-t, --test', 'test against our config.json' );


// Parse the arguments passed into this program.
program.parse( process.argv );

// Get the options passed in based on the commander getOpts definitions.
let options = program.opts( );

// Always create the schema file
createSchemaFile( );


if ( options.test )
   testGeneratedSchema( );

// The bracket level is a good indication of overall success
return bracketLevel;
